<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="阿晨的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="阿晨的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="刘晨">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>阿晨的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">阿晨的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">年度最佳摸鱼选手</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘晨"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">刘晨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/Java-03-%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/Java-03-%E9%AB%98%E7%BA%A7/" class="post-title-link" itemprop="url">Java-03-高级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-16 22:58:04" itemprop="dateCreated datePublished" datetime="2020-11-16T22:58:04+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-24 14:49:56" itemprop="dateModified" datetime="2020-11-24T14:49:56+08:00">2020-11-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Day-001"><a href="#Day-001" class="headerlink" title="Day 001"></a>Day 001</h4><blockquote>
<!-- Part 001 -->

<p>※ 在计算机中，我们把一个任务称为一个<span style="color:red">进程</span>；某些进程内部还需要同时执行多个子任务，我们把这些子任务称为<span style="color:red">线程</span>。进程与线程之间的关系为：一个进程可以包含多个线程，但至少会有一个线程。<strong>注</strong>：操作系统调度的最小任务单位不是进程，而是线程！</p>
<p>※ 同一个应用程序中，既可以有多个进程，又可以有多个线程，因此，实现多任务的方法有以下几种：<span style="color:blue">多进程模式</span>（每个进程只有一个线程）；<span style="color:blue">多线程模式</span>（一个进程有多个线程）；<span style="color:blue">多进程加多线程模式</span>（每个进程有多个线程）。</p>
<p>※ 与多线程相比，多进程的缺点在于：创建进程比创建线程开销大，尤其是在<code>Windows</code>系统上；进程间通信比线程间通信慢，因为线程间通信是读写同一个变量，速度很快。与多进程相比，多线程的缺点在于：稳定性较差，因为在多进程的情况下，一个进程崩溃不会影响其它进程，而在多线程的情况下，任何一个线程崩溃都将导致整个进程崩溃。</p>
<p>※ <code>Java</code>语言内置了多线程支持：一个<code>Java</code>程序实际上是一个<code>JVM</code>进程，<code>JVM</code>进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，还可以启动多个线程。此外，<code>JVM</code>还有负责垃圾回收的其它工作线程等。<strong>注</strong>：多线程模型是<code>Java</code>程序最基本的并发模型，后继读写网络、数据库、<code>Web</code>开发等都依赖于<code>Java</code>多线程模型。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 创建新线程有以下三种方式：</p>
<p>👉 继承<code>Thread</code>类，并重写<code>run()</code>方法；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>👉 创建实现<code>Runnable</code>接口的类，并在创建<code>Thread</code>实例时传入；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>👉 借助匿名类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 调用<code>run()</code>方法是无法启动新线程的，只是相当于调用了一个普通的<code>Java</code>方法。若想启动新线程，必须调用<code>start()</code>方法。<strong>注</strong>：在<code>Thread</code>类的源码中可以看到，<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示该方法是由<code>JVM</code>虚拟机内部的<code>C</code>代码实现的，而非<code>Java</code>代码。</p>
<p>※ 可以对线程设定优先级，设定优先级的方法为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：操作系统对优先级高的线程调度更为频繁，但并不能保证优先级高的线程一定会先执行。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>Java</code>线程的状态有以下几种：<span style="color:blue"><code>New</code></span>，新创建的线程，尚未运行；<span style="color:blue"><code>Runnable</code></span>，运行中的线程，正在执行<code>run()</code>方法；<span style="color:blue"><code>Blocked</code></span>：运行中的线程，因为某些操作被阻塞而挂起；<span style="color:blue"><code>Waiting</code></span>：运行中的线程，因为某些操作在等待中；<span style="color:blue"><code>Timed Waiting</code></span>：运行中的线程，因为执行<code>sleep()</code>方法在计时等待；<span style="color:blue"><code>Terminated</code></span>：线程已终止。</p>
<p>※ 线程终止的原因有以下三种：正常终止，即<code>run</code>方法执行到<code>return</code>语句返回；意外终止，即<code>run()</code>方法因未捕获的异常导致线程终止；对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</p>
<p>※ 通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束，也可以指定等待时间，待超过等待时间后便不再等待。此外，对已经运行结束的线程调用<code>join()</code>方法会立即返回。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 线程在执行一个长时间的任务时，可能需要被中断。<span style="color:blue">中断线程</span>就是其它线程给目标线程发送一个请求，目标线程在收到请求后，结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。中断线程非常简单，只需要在其它线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身是否是<code>interrupted</code>状态，若是则立刻结束运行。<strong>注</strong>：目标线程能否正确响应其它线程发来的中断请求，需要看具体代码。</p>
<p>※ 若对处于等待状态的线程调用<code>interrupt()</code>方法，线程的<code>join()</code>方法将会抛出<code>InterruptedException</code>异常。换句话说，若线程捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>异常，就说明有其它线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应立刻结束运行。</p>
<p>※ 另一个常用的中断线程的方法为设置标志位，即用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把该标志位设置为<code>false</code>，便可以让线程结束。<strong>注</strong>：标志位应为线程间共享变量，用关键字<code>volatile</code>标记，从而确保每个线程都能读取到更新后的变量值。</p>
<p>※ 为什么要对线程间共享的变量用<code>volatile</code>声明？这涉及到<code>Java</code>的内存模型。在<code>Java</code>虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，会先获取一个副本，并保存在自己的工作内存中。若线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时刻是不确定的。这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。因此，<code>volatile</code>关键字的目的是告诉虚拟机：每次访问变量时，总是获取内存的最新值；每次修改变量后，立刻回写到主内存。<!-- 存疑 --></p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <span style="color:blue">守护线程</span>是指为其它线程服务的线程。在<code>JVM</code>中，待所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。<strong>注</strong>：虚拟机退出后，非守护线程自然也就结束了，换句话说，非守护线程不用刻意去关闭。</p>
<p>※ 守护线程不能持有任何需要关闭的资源，如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<p>※ 创建守护线程，只需要在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>方法将该线程标记为守护线程。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。这时，若多个线程同时读写共享变量，便会出现数据不一致的问题。对共享变量进行读取和写入时，必须保证是<span style="color:blue">原子操作</span>，即不能被中断的一个或一系列操作。</p>
<p>※ <code>Java</code>程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：在使用<code>synchronized</code>的时候，不用担心抛出异常，因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁。</p>
<p>※ 虽然<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题，但是带来了性能下降，这不但是因为代码块无法并发执行，还因为加锁和解锁需要消耗一定的时间。</p>
<p>※ <code>JVM</code>规范定义了几种原子操作：基本类型赋值（<code>long</code>、<code>double</code>除外）；引用类型赋值。对于单条原子操作来说并不需要同步！<strong>注</strong>：<code>long</code>、<code>double</code>是64位数据，<code>JVM</code>没有明确规定64位赋值操作是不是同一个原子操作，但是在<code>X64</code>平台的<code>JVM</code>是把<code>long</code>和<code>double</code>赋值作为原子操作实现的。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 让线程自己选择锁对象往往会使代码逻辑混乱，并且不利于封装，更好的方法是把<code>synchronized</code>逻辑封起来，即：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样一来，线程调用<code>add()</code>方法时，将不必关心同步逻辑，因为<code>synchronized</code>代码块在该方法内部。此外，<code>synchronized</code>锁住的对象为<code>this</code>，即当前实例，这使得创建多个<code>Counter</code>实例时，它们之间互不影响。</p>
<p>※ 若一个类被设计为允许多线程正确访问，则称该类为<span style="color:blue">线程安全</span>的。<code>Java</code>标准库中的<code>StringBuilder</code>是线程安全的；一些不变类，如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程访问时只能读不能写，也是线程安全的；此外，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>※ 当锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法，即：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法也被称为同步方法，表示整个方法都必须用<code>this</code>实例加锁。</p>
<p>※ 对于<code>static</code>实例，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是注意到任何一个类都有一个由<code>JVM</code>自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。<!-- 存疑 --></p>
</blockquote>
<blockquote>
<!-- Part 008 -->

<p>※ <code>JVM</code>允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，称为<span style="color:blue">可重入锁</span>。</p>
<p>※ 当多线程各自持有不同的锁，并互相试图获取对方已持有的锁时，将导致无限等待，此时便陷入了<span style="color:blue">死锁</span>。</p>
<p>※ 在编写多线程应用时，要特别注意防止死锁，因为死锁一旦形成，就只能强制结束<code>JVM</code>进程。避免死锁的方法为多线程获取锁的顺序要一致！</p>
</blockquote>
<blockquote>
<!-- Part 009 -->

<p>※ 多线程协调运行的原则为：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<p>※ <code>wait</code>和<code>notify</code>用于多线程协调运行，在<code>synchronzied</code>内部可以调用<code>wait()</code>使线程进入等待状态，但必须在已获得的锁对象上调用<code>wait()</code>方法；在<code>synchronzied</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其它等待线程，但必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法。<strong>注</strong>：已唤醒的线程需要重新获得锁后才能继续执行。<!-- 存疑（你给我解释解释，什么TM的叫TM的已获得的锁对象） --></p>
</blockquote>
<blockquote>
<!-- Part 010 -->

<p>※ <code>ReentrantLock</code>可以用于替代<code>synchronized</code>进行同步，与<code>synchronized</code>相比，<code>ReentrantLock</code>可以在指定时间范围内尝试获取锁，一旦超过指定时间范围，程序可以做一些额外处理，而不是无限等待下去，这样可以有效避免死锁：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// lock() 方法表示当前线程占用 lock 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 必须调用 unlock() 方法进行手动释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 011 -->

<p>※ <code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步，那么该如果实现<code>synchronized</code>下的<code>wait</code>和<code>notify</code>呢？可以使用<code>Condition</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>对象。</p>
<p>※ <code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法在原理上和<code>synchronized</code>锁对象提供的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>方法是一致的，并且行为也是一样的：<code>await()</code>用于释放当前锁并进入等待状态；<code>signal()</code>用于唤醒某个等待线程；<code>signalAll()</code>用于唤醒所有等待线程。<strong>注</strong>：与<code>trylock()</code>类似，<code>await()</code>可以在等待指定时间后自己醒来。</p>
</blockquote>
<blockquote>
 <!-- Part 012 -->

<p>※ 在读多写少的场景中，利用<code>ReadWriteLock</code>可以提高读取效率：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：在论坛中，回复可以视为写入操作，它是不频繁的，浏览可以视为读取操作，它是频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
</blockquote>
<blockquote>
<!-- Part 013 -->

<p>※ 在<code>Java 8</code>中，引入了新的读写锁<code>StampedLock</code>，与<code>ReadWriteLock</code>相比，前者的改进之处在于：读的过程中也允许获取写锁后写入。但是这样可能会导致读的数据不一致，因此需要一点儿额外的代码来判断读的过程中是否有写入：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>ReadWriteLock</code>相比，写入的加锁是完全一致的，不同的是读取。首先，通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号；接着，待读取完成后，通过<code>validate()</code>去验证版本号，若在读取过程中没有写入，版本号不变，验证成功；若在读取过程中有写入，版本号改变，验证失败，此时将再通过获取悲观读锁进行读取。可见，<code>StampedLock</code>将读锁细分为乐观读锁和悲观读锁，其中，<span style="color:blue">乐观读锁</span>是指乐观地估计读的过程中大概率不会有写入；<span style="color:blue">悲观读锁</span>是指读的过程中拒绝有写入。然而，如此细分也是有代价的：一是代码更加复杂，二是<code>StampedLock</code>为不可重入锁，不能在一个线程中反复获取同一个锁！</p>
</blockquote>
<blockquote>
<!-- Part 014 -->

<p>※ 针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Queue</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包提供了对应的并发集合类：</p>
<table>
<thead>
<tr>
<th align="center">interface</th>
<th align="center">non-thread-safe</th>
<th align="center">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>List</code></td>
<td align="center"><code>ArrayList</code></td>
<td align="center"><code>CopyOnWriteArrayList</code></td>
</tr>
<tr>
<td align="center"><code>Map</code></td>
<td align="center"><code>HashMap</code></td>
<td align="center"><code>ConcurrentHashMap</code></td>
</tr>
<tr>
<td align="center"><code>Set</code></td>
<td align="center"><code>HashSet/TreeSet</code></td>
<td align="center"><code>CopyOnWriteArraySet</code></td>
</tr>
<tr>
<td align="center"><code>Queue</code></td>
<td align="center"><code>ArrayDeque/LinkedList</code></td>
<td align="center"><code>ArrayBlockingQueue/LinkedBlockingQueue</code></td>
</tr>
<tr>
<td align="center"><code>Deque</code></td>
<td align="center"><code>ArrayDeque/LinkedList</code></td>
<td align="center"><code>LinkedBlockingDeque</code></td>
</tr>
</tbody></table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。</p>
<p>※ <code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该转换器实际上只是用一个包装类包装了非线程安全的<code>Map</code>，然后对所有读写方法都用<code>synchronized</code>加锁，这样获取的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，不推荐使用！</p>
</blockquote>
<blockquote>
<!-- Part 015 -->

<p>※ <code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，这些封装类位于<code>java.util.concurrent.atomic</code>包中。</p>
<p>※ <code>Atomic</code>类是通过<strong>无锁</strong>的方式实现的线程安全访问，它的主要原理是利用了<code>CAS(Compare and Set)</code>。其中，<code>CAS</code>是指若<code>AtomicInteger</code>的当前值为<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>；若<code>AtomicInteger</code>的当前值不为<code>prev</code>，就什么都不干，返回<code>false</code>。通过<code>CAS</code>操作并配合<code>do ... while</code>循环，即使其它线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。<strong>注</strong>：该类适用于计数器，累加器等。</p>
</blockquote>
<blockquote>
<!-- Part 016 -->

<p>※ <code>Java</code>语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁线程需要消耗大量时间。如果可以复用一组线程，那么就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程，这种能接收大量小任务并进行分发处理的就是<span style="color:blue">线程池</span>。换句话说，线程池内部维护了若干个线程，没有任务的时候，这些线程均处于等待状态，有新任务的时候，就分配一个空闲线程执行。若所有线程均处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>※ <code>Java</code>标准库提供了<code>ExecutorService</code>接口表示线程池，其典型用法如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<code>ExecutorService</code>接口，<code>Java</code>标准库提供的几个常用实现类有：<code>FixedThreadPoll</code>，线程数固定的线程池；<code>ChchedThreadPoll</code>，线程数根据任务动态调整的线程池；<code>SingleThreadExecutor</code>，仅单线程执行的线程池。</p>
<p>※ 线程池在程序结束的时候要关闭！使用<code>shutdown()</code>方法关闭线程池时，会等待正在执行的任务完成后再关闭；使用<code>shutdownNow()</code>方法关闭线程池时，会立即停止正在执行的任务；使用<code>awaitTermination()</code>方法关闭线程池时，会等待指定的时间让线程池关闭。</p>
<p>※ 还有一种任务，需要定期反复执行，如每秒刷新证券的价格。这种任务本身固定，需要反复执行，可以使用<code>ScheduledThreadPool</code>，放入其中的任务可以定期反复执行：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>FixedRate</code>和<code>FixedDelay</code>的区别：前者是指任务总是以固定时间间隔触发，不管执行时间有多长；后者是指上一次任务执行完毕后，再等待固定的时间间隔执行任务。<span style="color:red"><strong>注</strong></span>：在<code>FixedRate</code>模式下，假设任务的执行时间超过了其运行周期，则后续执行可能会延迟开始，但不会并发执行；此外，若任务的任何执行遇到了异常，将禁止后续任务的执行。</p>
<p>※ <code>Java</code>标准库提供的<code>java.util.Timer</code>类同样可以定期执行任务，但是，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPoll</code>可以调度多个定时任务，因此完全可以用<code>ScheduledThreadPoll</code>取代旧的<code>Timer</code>。</p>
</blockquote>
<blockquote>
<!-- Part 017 -->

<p>※ 使用<code>Java</code>标准库提供的线程池执行多个任务是非常方便的，我们提交的任务只需要实现<code>Runnable</code>接口即可让线程池去执行：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，<code>Runnable</code>接口没有返回值，如果任务需要一个返回结果，那么只能保存到变量，并提供额外的方法读取。为此，<code>Java</code>标准库提供了一个<code>Callable</code>接口，与<code>Runnable</code>接口相比，它多了一个返回值：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。那么问题来了，该如何获取异步执行的结果呢？如果仔细查看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型的实例，该实例代表一个未来能获取结果的对象：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们提交一个<code>Callable</code>任务后，同时会获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用该对象的<code>get()</code>方法，即可获得异步执行的结果。<strong>注</strong>：在调用<code>get()</code>时，如果异步任务已经执行完成，则可以直接获得结果；如果异步任务尚未执行完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>※ 一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：<code>get()</code>，获取结果，但可能会等待；<code>get(long timeout, TimeUnit unit)</code>，获取结果，但只等待指定的时间；<code>isDone()</code>，判断任务是否已经完成；<code>cancel(boolean mayInterruptIfRunning)</code>，取消当前任务。</p>
</blockquote>
<blockquote>
<!-- Part 018 -->

<p>※ 使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询查看<code>isDone()</code>是否为<code>true</code>，这两种方法均不是很好，因为主线程也会被迫等待。从<code>Java 8</code>引入了<code>CompletableFuture</code>，它对<code>Future</code>进行了改进，可以传入回调对象，当异步任务完成或者发生异常时，将自动调用回调对象的回调方法。</p>
<p>※ 创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象。紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象；异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象。</p>
<p>※ 与<code>Future</code>相比，<code>CompletableFuture</code>更大的优势在于：既可以串行化执行，又可以并行化执行。具体地，<code>thenApplyAsync()</code>方法用于串行化另一个<code>CompletableFuture</code>；<code>anyOf()</code>和<code>allOf()</code>方法用于并行化多个<code>CompletableFuture</code>。</p>
</blockquote>
<blockquote>
<!-- Part 019 -->

<p>※ <code>Java 7</code>开始引入了一种新的<code>Fork/Join</code>线程池，它可以执行一种特殊的任务：将一个大任务拆成多个小任务并行执行。<strong>注</strong>：任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p>
</blockquote>
<blockquote>
<!-- Part 020 -->

<p>※ <code>Thread</code>对象代表一个线程，在代码中调用<code>Thread.currentThread()</code>方法可以获取当前线程。</p>
<p>※ 在一个线程中，横跨若干种方法调用，需要传递的对象，通常称之为上下文，它是一种状态，可以是用户身份，也可以是任务信息等。给每个方法增加一个上下文参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，上下文参数就传不进去了。<code>Java</code>标准库提供了一个特殊的<code>TheadLocal</code>，它可以在一个线程中传递同一个对象。</p>
<p>※ <code>ThreadLocal</code>实例通常以静态字段初始化，其典型使用方式如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：<code>ThreadLocal</code>一定要在<code>finally</code>中清除，因为当前线程执行完相关代码后，很可能会被重新放入线程池中，若<code>ThreadLocal</code>没有被清除，会把上一次的状态带进去。</p>
<p>※ 为了保证能释放<code>ThreadLocal</code>关联的实例，可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用的时候，借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) &#123;...&#125;</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>
</blockquote>
<h4 id="Day-002"><a href="#Day-002" class="headerlink" title="Day 002"></a>Day 002</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>Maven</code>是一个<code>Java</code>项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。</p>
<p>※ 使用<code>Maven</code>管理的普通<code>Java</code>项目的目录结构默认如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，项目的根目录<code>a-maven-project</code>为项目名，它有一个<span style="color:blue">项目描述文件</span><code>pom.xml</code>，存放源码的目录为<code>src/main/java</code>，存放资源文件的目录为<code>src/main/resources</code>，存放测试源码的目录为<code>src/test/java</code>，存放测试资源文件的目录为<code>src/tset/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。</p>
<p>※ 通常情况下，项目描述文件<code>pom.xml</code>的内容如下所示：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，<code>groupId</code>类似于<code>Java</code>的包名，通常是公司或组织名称，<code>artifactId</code>类似于<code>Java</code>的类名，通常是项目名称，再加上<code>version</code>，即可作为唯一标识。在引用其它第三方库时，也是通过这三个变量确定的，如<code>commons-logging</code>：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，<code>Maven</code>就会自动下载这个依赖包并把它方法<code>classpath</code>中。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>Maven</code>定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：其中，默认的<code>compile</code>依赖最常用，<code>Maven</code>会把这种类型的依赖直接放入<code>classpath</code>中；<code>test</code>依赖表示仅在测试时使用，正常运行时不需要，如<code>JUnit</code>；<code>runtime</code>依赖表示编译时不需要，但运行时需要，如<code>MySQL</code>；<code>provided</code>依赖表示编译时需要，但运行时不需要，如<code>servle-api</code>。</p>
<p>※ <code>Maven</code>通过对<code>jar</code>包进行<code>PGP</code>签名确保任何一个<code>jar</code>包一经发布就无法修改，修改<code>jar</code>包的唯一方法为发布一个新版本。因此，某个<code>jar</code>包一旦被<code>Maven</code>下载过，即可永久地安全缓存在本地。<strong>注</strong>：只有以<code>-SNAPSHOT</code>结尾的版本号会被<code>Maven</code>视为开发版本，开发版本每次都会重复下载，这种<code>SNAPSHOT</code>版本只能用于内部私有的<code>Maven repo</code>，公开发布的版本不允许出现。</p>
<p>※ <code>Maven</code>并不会每次都从中央仓库下载<code>jar</code>包，一个<code>jar</code>包一旦被下载过，就会被<code>Maven</code>自动缓存在本地目录（用户主目录下的<code>.m2</code>目录）。因此，除第一次编译时因为下载需要时间会比较慢外，后续过程因为有本地缓存，并不会很慢。</p>
<p>※ 使用<code>Maven</code>镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>setting.xml</code>配置文件，内容如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置镜像仓库后，<code>Maven</code>的下载速度会很快。</p>
<p>※ 如果需要引用一个第三方组件，可以通过<a href="[Maven Central Repository Search](https://search.maven.org/)">search.maven.org</a>搜索关键字，找到对应的组件后直接复制即可。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>Maven</code>的<span style="color:blue">生命周期</span>由一系列阶段（<code>phase</code>）构成，以内置的生命周期<code>default</code>为例，它包含以下<a href="[构建流程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1309301196980257)">阶段</a>。如果我们运行<code>mvn package</code>，<code>Maven</code>就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个阶段为止；如果我们运行<code>mvn compile</code>，<code>Maven</code>也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>。此外，<code>Maven</code>另一个常用的生命周期为<code>clean</code>，它会执行三个阶段：<code>pre-clean</code>、<code>clean</code>、<code>post-clean</code>。</p>
<p>※ 在实际开发中，常用的命令有：<code>mvn clean</code>，清理所有生成的<code>class</code>和<code>jar</code>；<code>mvn clean compile</code>，先清理再执行到<code>compile</code>；<code>mvn clean test</code>，先清理再执行到<code>test</code>；<code>mvn clean package</code>：先清理再执行到<code>package</code>。<strong>注</strong>：大多数阶段在执行过程中，因为通常没有在<code>pom.xml</code>中配置相关设置，因此什么事情都不做，经常用到的阶段其实只有几个，如<code>clean</code>、<code>compile</code>、<code>test</code>、<code>package</code>。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 实际上，执行每个阶段，都是通过某个插件来执行的，<code>Maven</code>本身并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个<code>goal</code>来完成编译。因此，使用<code>Maven</code>实际上就是配置好需要使用的插件，然后通过阶段调用它们。<strong>注</strong>：若标准插件无法满足需求，还可以使用自定义插件。使用自定义插件时，需要声明。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <code>Maven</code>可以有效管理多个模块，只需要把每个模块当作一个独立的<code>Maven</code>项目，每个项目有各自独立的<code>pom.xml</code>。</p>
<p>※ 不同模块的<code>pom.xml</code>高度相似，因此，可以提取出共同部分作为<code>parent</code>：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>parent</code>的<code>&lt;packing&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何<code>Java</code>代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 安装完<code>Maven</code>之后，系统所有项目都会使用全局安装的这个<code>Maven</code>版本，但是对于某些项目来说，可能必须使用某个特定的<code>Maven</code>版本，这个时候就可以使用<code>Maven Wrapper</code>（<span style="color:blue"><code>mvnw</code></span>），它可以负责给这些项目安装指定版本的<code>Maven</code>，而其它项目不受影响。<code>mvnw</code>的另一个作用是把项目的<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>提交到版本库中，可以使所有开发人员使用统一的<code>Maven</code>版本。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 使用<code>Maven</code>发布一个<code>Artifact</code>时，可以发布到本地，然后由静态服务器提供<code>repo</code>服务，使用方必须声明<code>repo</code>地址；可以发布到<code>central.sonatype.org</code>，并自动同步到<code>Maven</code>中央仓库，需要前期申请账号以及本地配置；可以发布到<code>Github Packages</code>作为私有仓库使用，必须提供<code>Token</code>以及正确的权限才能使用和发布。</p>
</blockquote>
<h4 id="Day-003"><a href="#Day-003" class="headerlink" title="Day 003"></a>Day 003</h4><blockquote>
<!-- Part 001 -->

<p>※ 使用<code>Java</code>进行网络编程时，由虚拟机实现了底层复杂的网络协议，<code>Java</code>程序只需要调用<code>Java</code>标准库提供的接口，即可简单高效地编写网络程序。</p>
<p>※ <code>TCP/IP</code>协议泛指互联网协议，其中最重要的两个协议是<code>TCP</code>协议和<code>IP</code>协议。只有使用<code>TCP/IP</code>协议的计算机才能够联入互联网，使用其它网络协议是无法联入互联网的。</p>
<p>※ 在互联网中，一个<code>IP</code>地址用于唯一标识一个网络接口。一台连入互联网的计算机肯定有一个<code>IP</code>地址，但也可能有多个<code>IP</code>地址。<code>IP</code>地址既可以分为<code>IPv4</code>和<code>IPv6</code>，又可以分为公网<code>IP</code>地址和内网<code>IP</code>地址。公网<code>IP</code>地址可以直接被访问，内网<code>IP</code>地址只能在内网访问。内网<code>IP</code>地址类似于：<code>192.168.*.*</code>，<code>10.*.*.*</code>。</p>
<p>※ 如果一台计算机有两块网卡，那么除了本机地址<code>127.0.0.1</code>，它还可以有两个<code>IP</code>地址，这两个<code>IP</code>地址可以分别接入两个网络，使得它们连接起来。<strong>注</strong>：通常连接两个网络的设备是路由器或者交换机。</p>
<p> ※ 每台计算机都需要正确配置<code>IP</code>地址和子网掩码，根据它们可以计算网络号。若两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信；若两台计算机计算出的网络号不同，说明两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，这种设备通常被称为<span style="color:blue">网关</span>。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫做<span style="color:blue">路由</span>。</p>
<p>※ 域名解析服务器<code>DNS</code>负责把域名翻译成对应的<code>IP</code>，客户端再根据<code>IP</code>地址访问服务器。<strong>注</strong>：用<code>nslookup</code>可以查看域名对应的<code>IP</code>地址。</p>
<p>※ <code>OSI</code>网络模型是<code>ISO</code>组织定义的一个计算机互联标准模型，目的是为了简化网络各层的操作，提供标准接口便于实现和维护，该模型从上到下依次是：应用层，提供应用程序之间的通信；表示层，处理数据的格式，加解密等；会话层，负责建立和维护对话；传输层，负责提供端到端的可靠传输；网络层，负责根据目标地址选择路由来传输数据；链路层和物理层负责把数据进行分片并且真正通过物理网络传输，如无线网和光纤等。互联网使用的<code>TCP/IP</code>模型并不是对应到<code>OSI</code>的<code>7</code>层模型，而是大致对应<code>OSI</code>的<code>5</code>层模型。</p>
<p>※ <code>IP</code>协议是一种分组交换传输协议；<code>TCP</code>协议是一种面向连接，可靠传输的协议；<code>UDP</code>协议是一种非面向连接，不可靠传输的协议。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>Socket</code>是一个抽象概念，应用程序通过一个<code>Socket</code>来建立一个远程连接，而<code>Socket</code>内部通过<code>TCP/IP</code>协议把数据传输到网络。</p>
<p>※ 一个<code>Socket</code>就是由<code>IP</code>地址和端口号组成，端口号总是由操作系统分配，它是<code>0 ~ 65535</code>之间的数字，其中，小于<code>1024</code>的端口属于特权端口，需要管理员权限，大于<code>1024</code>的端口可以由任意用户的应用程序打开。</p>
<p>※ 使用<code>Socket</code>进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器，它会主动监听某个指定的端口，另一个进行必须充当客户端，它必须主动连接服务器的<code>IP</code>地址和指定端口，如果连接成功，服务器和客户端就成功地建立了一个<code>TCP</code>连接，双方后继就可以随时发送和接收数据。因此，当<code>Socket</code>连接成功地再服务器和客户端之间建立后，对服务器来说，它的<code>Socket</code>是指定的<code>IP</code>地址和指定的端口号；对客户端来说，它的<code>Socket</code>是它所在计算机的<code>IP</code>地址和一个由操作系统分配的随机端口号。</p>
<p>※ 当<code>Socket</code>连接建立成功后，无论是服务器，还是客户端，都使用<code>Socket</code>实例进行网络通信。因为<code>TCP</code>是一种基于流的协议，因此，<code>Java</code>标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装<code>Socket</code>的数据流。</p>
<p>※ 使用<code>Java</code>进行<code>TCP</code>编程时，需要使用<code>Socket</code>模型：服务器用<code>ServerSocket</code>监听指定端口；客户端使用<code>Socket(InetAddress, port)</code>连接服务器；服务器用<code>accept()</code>接收连接并返回<code>Socket</code>；双方通过<code>Socket</code>打开<code>InputStream/OutputStream</code>读写数据。<strong>注</strong>：服务器通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率。</p>
<p>※ 在写入网络数据时，要调用<code>flush()</code>方法，若不调用，可能会发现客户端和服务器都收不到数据，这是因为我们以流的形式写入数据时，并不是一写入就立刻发送到网络，而是先写入到内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是提高传输效率。若缓冲区的数据很少，而我们又想把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 与<code>TCP</code>相比，<code>UDP</code>没有创建连接，数据包也是一次收发一个，因此没有流的概念。</p>
<p>※ 在<code>Java</code>中使用<code>UDP</code>编程，仍然需要使用<code>Socket</code>，因为应用程序在使用<code>UDP</code>时必须指定<code>IP</code>地址和端口号。<strong>注</strong>：<code>UDP</code>端口和<code>TCP</code>端口虽然都使用<code>0 ~ 65535</code>，但他们属于两套独立的端口，即一个应用程序用<code>TCP</code>占用了端口<code>1234</code>，不影响另一个应用程序用<code>UDP</code>占用端口<code>1234</code>。</p>
<p>※ 服务器使用<code>DatagramSocket(port)</code>监听端口；客户端使用<code>DatagramSocket.connect</code>指定远程地址和端口；双方通过<code>receive()</code>和<code>send()</code>读写数据；<code>DatagramSocket</code>没有<code>IO</code>流接口，数据被直接写入<code>byte[]</code>缓冲区。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ <code>SMTP</code>协议是一个建立在<code>TCP</code>协议之上的协议，任何程序发送邮件都必须遵守<code>SMTP</code>协议。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <code>HTTP</code>是目前<code>    Web</code>应用程序使用最广泛的基础协议，翻译为超文本传输协议。</p>
<p>※ 当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立<code>TCP</code>连接，并且服务器总是使用<code>80</code>端口和加密端口<code>443</code>；然后，浏览器向服务器发送一个<code>HTTP</code>请求，服务器收到后返回一个<code>HTTP</code>响应，并且在响应中包含了<code>HTML</code>网页内容，这样，浏览器解析<code>HTML</code>后就可以给用户显示网页了。</p>
<p>※ <code>HTTP</code>请求的格式是固定的，由<code>Header</code>和<code>Body</code>两部分构成。第一行总是“请求方法 路径 <code>HTTP</code>版本”，后继的每一行都是固定的<code>Header: Value</code>格式，称之为<code>HTTP Header</code>，服务器依靠某些特定的<code>Header</code>来识别客户端请求，其中，<code>Host</code>表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠<code>Host</code>来识别请求；<code>User-Agent</code>表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠其判断客户端类型；<code>Accept</code>表示客户端能处理的<code>HTTP</code>响应格式，<code>*/*</code>表示惹你格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示<code>PNG</code>格式的图片；<code>Accept-Language</code>表示客户端接收的语言，多种语言按照优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。<strong>注</strong>：如果是<code>GET</code>请求，那么该<code>HTTP</code>请求只有<code>Header</code>，没有<code>Body</code>；如果是<code>POST</code>请求，那么该<code>HTTP</code>请求带有<code>Body</code>，以一个空行分隔。一个典型的带有<code>Body</code>的<code>HTTP</code>请求如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 30</span><br><span class="line"></span><br><span class="line">username=hello&amp;password=123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示<code>Body</code>类型，<code>Content-Length</code>表示<code>Body</code>长度，这样服务器就可以根据请求的<code>Header</code>和<code>Body</code>做出正确的响应。此外，<code>GET</code>请求的参数必须附加在<code>URL</code>上，并以<code>URLEncode</code>方式编码。</p>
<p>※ <code>HTTP</code>响应同样是由<code>Header</code>和<code>Body</code>两部分构成。第一行总是“<code>HTTP</code>版本 响应代码 响应说明”。客户端只依赖响应代码判断<code>HTTP</code>响应是否成功，其中，<code>1**</code>表示一个提示性响应，如<code>101</code>表示将切换协议，常见于<code>WebSocket</code>连接；<code>2**</code>表示一个成功响应，如<code>200</code>表示成功，<code>206</code>表示只发送了部分内容；<code>3**</code>表示一个重定向响应，如<code>301</code>表示永久重定向，<code>303</code>表示客户端应该按照指定路径重新发送请求；<code>4**</code>表示一个因为客户端问题导致的错误响应，如<code>400</code>表示因为<code>Content-Type</code>等各种原因导致的无效请求，<code>404</code>表示指定的路径不存在；<code>5**</code>表示一个因为服务器问题导致的错误响应，如<code>500</code>表示服务器内部故障，<code>503</code>表示服务器暂时无法响应。</p>
<p>※ 当浏览器收到第一个<code>HTTP</code>响应并解析<code>HTML</code>后，又会发送一系列<code>HTTP</code>请求，如<code>GET /log.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器。因此，服务器总是被动地接收客户端的一个<code>HTTP</code>请求，然后响应它；客户端则根据需要发送若干个<code>HTTP</code>请求。</p>
<p>※ 对于最早期的<code>HTTP/1.0</code>协议，每次发送一个<code>HTTP</code>请求后，客户端都需要先创建一个新的<code>TCP</code>连接，待收到服务器响应后，关闭这个<code>TCP</code>连接。由于建立<code>TCP</code>连接比较耗时，为了提高效率，<code>HTTP/1.1</code>协议允许在一个<code>TCP</code>连接中反复请求-响应，这样就能大大提高效率。然而，<code>HTTP</code>协议是一个请求-响应协议，客户端在发送了一个<code>HTTP</code>请求后，必须等待服务器响应后才能发送下一个请求，这样以来，若某个响应太慢，将会堵住后面的请求。因此，为了进一步提速，<code>HTTP/2.0</code>允许客户在没有收到响应的时候，发送多个<code>HTTP</code>请求，服务器返回响应时，不一定按照顺序返回，只要双方能识别出哪个响应对应哪个请求，即可做到并行发送和接收。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ <code>Java</code>的<code>RMI</code>远程调用是指：一个<code>JVM</code>中的代码可以通过网络远程调用另一个<code>JVM</code>的某个方法，提供服务的一方称为服务器，实现远程调用的一方称之为客户端。</p>
<p>※ <code>RMI</code>通过自动生成<code>stub</code>和<code>skeleton</code>实现网络调用，客户端只需要查找服务并获得接口实例，服务端只需要编写实现类并注册为服务。此外，<code>RMI</code>的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把<code>1099</code>端口暴露再公网上作为对外服务。</p>
</blockquote>
<h4 id="Day-004"><a href="#Day-004" class="headerlink" title="Day 004"></a>Day 004</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>XML</code>是可扩展标记语言的缩写，属于一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。<code>XML</code>有几个特点：一是纯文本，默认使用<code>UTF-8</code>编码；二是可嵌套，适合表示结构化数据。</p>
<p>※ <code>XML</code>有固定的结构，首行必定是<code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>，有时还可以加上可选的编码。紧接着，如果以类似<code>&lt;!DOCTYPE note SYSTEM &quot;book.dtd&quot;&gt;</code>声明的是<span style="color:blue">文档定义类型</span><code>DTD</code>，<code>DTD</code>是可选的。接下来是<code>XML</code>的文档内容，一个<code>XML</code>文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性。</p>
<p>※ 验证<code>XML</code>正确性最简单的方式是通过浏览器验证，即直接把<code>XML</code>文件拖拽到浏览器窗口，若格式错误，浏览器将会报错。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>XML</code>为树形结构的文档，它有两种标准的解析<code>API</code>：<code>DOM</code>，一次性读取<code>XML</code>，并在内存中表示为树形结构；<code>SAX</code>，以流的形式读取<code>XML</code>，使用事件回调。<strong>注</strong>：<code>DOM</code>解析速度慢，内存占用大；<code>SAX</code>读取速度快，内存站占用小。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>JSON</code>是轻量级的数据表示方式，常用于<code>Web</code>应用；<code>Jackson</code>可以实现<code>JavaBean</code>和<code>JSON</code>之间的转换；可以通过<code>Module</code>扩展<code>Jackson</code>能处理的数据类型；可以自定义<code>JsonSerializer</code>和<code>JsonDeserializer</code>来定制序列化和反序列化。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/09/Java-02-%E4%B8%AD%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/Java-02-%E4%B8%AD%E7%BA%A7/" class="post-title-link" itemprop="url">Java中级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-09 11:40:15" itemprop="dateCreated datePublished" datetime="2020-11-09T11:40:15+08:00">2020-11-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-16 22:57:45" itemprop="dateModified" datetime="2020-11-16T22:57:45+08:00">2020-11-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Day-001"><a href="#Day-001" class="headerlink" title="Day 001"></a>Day 001</h4><blockquote>
<!-- Part 001 -->

<p>※ 每加载一种<code>class</code>，<code>JVM</code>便会为其创建一个<code>Class</code>类型的实例，并将它们关联起来。在<code>Class</code>实例中，保存了该<code>class</code>的类名、包名、父类、实现的接口、所有方法、所有字段等，因此，若获取了某个<code>Class</code>实例，便可以通过该实例获取到该实例对应的<code>class</code>的所有信息。上述通过<code>Class</code>实例获取<code>class</code>信息的方法便称为<span style="color:blue">反射</span>。</p>
<p>※ 获取一个<code>class</code>的<code>Class</code>实例，存在以下三种方法：</p>
<ul>
<li>直接通过<code>class</code>的静态变量<code>class</code>获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过实例变量提供的<code>getClass()</code>方法获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;chen&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>通过静态方法<code>Class.forName()</code>获取（前提是知道<code>class</code>的完整类名）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：因为<code>Class</code>实例在<code>JVM</code>中是唯一的，因此上述方法获取的<code>Class</code>实例为同一个实例，可以直接用<code>==</code>进行比较。</p>
<p>※ 通常情况下，我们应该使用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们并不关心具体的子类型，只有在需要精确判断一个类型是不是某个<code>class</code>的时候，才会使用<code>==</code>判断。</p>
<p>※ <code>JVM</code>在执行<code>Java</code>程序的时候，并不是一次性把所有用到的<code>class</code>加载到内存，而是需要用到时才加载，这便是<code>JVM</code><span style="color:blue">动态加载</span><code>class</code>的特性。利用<code>JVM</code>的动态加载特性，可以在运行期间根据条件加载不同的实现类。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 反射<code>API</code>提供的<code>Field</code>类封装了字段的所有信息。</p>
<p>※ 利用<code>Class</code>实例的<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>和<code>getDeclaredFields()</code>方法可以获取<code>Field</code>实例。通过<code>Field</code>实例，可以获取字段信息，如<code>getName()</code>（名称），<code>getType()</code>（类型），<code>getModifiers()</code>（修饰符）；也可以读取或设置某个对象的字段（若存在访问限制，则首先需要调用<code>setAccessible(true)</code>来访问非<code>public</code>字段）。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 反射<code>API</code>提供的<code>Method</code>类封装了方法的所有信息。</p>
<p>※ 利用<code>Class</code>实例的<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclareMethod()</code>和<code>getDeclaredMethods()</code>方法可以获取<code>Method</code>实例。通过<code>Method</code>实例，可以获取方法信息，如<code>getName()</code>，<code>getModifiers()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>；也可以调用某个对象的方法。<strong>注</strong>：通过反射调用方法时，仍然遵守多态原则。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 反射<code>API</code>提供的<code>Constructor</code>类封装了构造方法的所有信息。</p>
<p>※ 利用<code>Class</code>实例的<code>getConstructor()</code>，<code>getConstructors()</code>等方法可以获取<code>Constructor</code>实例。通过<code>Constructor</code>实例，可以创建一个对象，如<code>newInstance(Object... parameters)</code>。<strong>注</strong>：其实也可以直接调用<code>Class</code>实例的<code>newInstance()</code>方法来创造实例，但是它只能调用该类的<code>public</code>无参数构造方法，若构造方法不是<code>public</code>或者带有参数，就无法通过<code>Class.newInstance</code>来创造。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ 利用<code>Class</code>实例可以获取继承关系，如<code>getSuperclass()</code>（获取父类类型），<code>getInterfaces()</code>（获取<strong>当前类</strong>实现的所有接口）。<strong>注</strong>：对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>。</p>
<p>※ 利用<code>Class</code>实例的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ <code>Java</code>标准库提供了<span style="color:green">动态代理</span>功能，允许在运行期间动态创建一个接口的实例。<!--存疑--></p>
</blockquote>
<h4 id="Day-002"><a href="#Day-002" class="headerlink" title="Day 002"></a>Day 002</h4><h4 id="Day-003"><a href="#Day-003" class="headerlink" title="Day 003"></a>Day 003</h4><blockquote>
<!-- Part 001 -->

<p>※ <span style="color:blue">泛型</span>是指编写模板代码来适应任意类型，其好处是在使用时不必对类型进行强制转换，可以通过编译器对类型进行检查。</p>
<p>※ 可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（<code>T</code>不能变），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（<code>T</code>不能变为父类）。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 使用泛型时，可以把泛型参数<code>&lt;T&gt;</code>替换为需要的<code>class</code>类型，也可以省略编译器能自动推断出的类型。</p>
<p>※ 不指定泛型参数类型时，编译器将会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型。</p>
<p>※ 可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 编写泛型时，需要定义泛型类型<code>&lt;T&gt;</code>。</p>
<p>※ 泛型可以同时定义多种类型，例如<code>Map&lt;K, V&gt;</code>。</p>
<p>※ 静态方法不能引用泛型类型<code>&lt;T&gt;</code>，必须定义其它类型（如<code>&lt;T&gt;</code>）来实现静态泛型方法。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ <code>Java</code>的泛型是采用<span style="color:red">擦拭法</span>实现的，擦拭法决定了泛型<code>&lt;T&gt;</code>存在以下缺点：不能是基本类型；不能获取带泛型类型的<code>Class</code>；不能判断带泛型类型的类型，例如<code>x instanceof Pair&lt;String&gt;</code>；不能实例化<code>T</code>类型。</p>
<p>※ 泛型方法要防止重复定义方法，例如<code>public boolean equals(T obj)</code>。</p>
<p>※ 子类可以获取父类的泛型类型。<!--存疑--></p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ 使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时：方法内部可以调用获取<code>Number</code>引用的方法，但不可以调用传入<code>Number</code>引用的方法（<code>null</code>除外），换句话说，使用<code>extends</code>通配符表示可以读，不能写。<span style="color:blue">上界通配符</span></p>
<p>※ 使用类似<code>&lt;? super Number&gt;</code>通配符作为方法参数时：方法内部可以调用传入<code>Number</code>引用的方法，但不可以调用获取<code>Number</code>引用的方法（<code>Object</code>除外），换句话说，使用<code>super</code>通配符表示可以写，不能读。<span style="color:blue">下界通配符</span></p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 部分反射<code>API</code>为泛型，例如<code>Class&lt;T&gt;</code>、<code>Constructor&lt;T&gt;</code>。</p>
<p>※ 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型。<!--存疑--></p>
</blockquote>
<h4 id="Day-004"><a href="#Day-004" class="headerlink" title="Day 004"></a>Day 004</h4><blockquote>
<!-- Part 001 -->

<p>※ 如果一个<code>Java</code>对象可以在内部持有若干其它<code>Java</code>对象，并对外提供访问接口，那么该对象被称之为集合。显然，数组便是一种集合。</p>
<p>※ <code>Java</code>主要提供了<code>3</code>种集合类：<code>List</code>、<code>Set</code>和<code>Map</code>，均定义在<code>java.util</code>包中。<code>Java</code>的集合设计有如下特点：接口与实现类分离；支持泛型；利用迭代器<code>Iterator</code>进行访问。</p>
<p>※ <code>Java</code>的集合设计比较久远，中间经历过大规模改进，有一些集合类不应该继续使用：<code>Hashstable</code>：一种线程安全的<code>Map</code>实现；<code>Vector</code>：一种线程安全的<code>List</code>实现；<code>Stack</code>：基于<code>Vector</code>实现的栈。还有一些接口也不应该继续使用：<code>Eumneration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 除使用<code>ArrayList</code>、<code>LinkedList</code>外，还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，<code>List.of()</code>方法不接受<code>null</code>。若传入<code>null</code>，将会抛出<code>NullPointerException</code>异常。</p>
<p>※ 在遍历<code>List</code>时，完全可以利用<code>for</code>循环，但是并不推荐，一是代码比较复杂，二是索引对于<code>LinkedList</code>来说访问速度较慢。推荐利用<code>Iterator</code>，它是由<code>List</code>的实例调用<code>iterator()</code>方法时创建的对象，知道如何遍历<code>List</code>，<span style="color:red">总是具有最高的访问效率</span>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 将<code>List</code>转换为数组有三种方法：调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组，该方法会导致类型信息丢失，因此实际应用较少；给<code>toArray(T[])</code>方法传入一个类型相同的数组，<code>List</code>内部自动将元素复制到传入的数组中；通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line"><span class="comment">// Way 1:</span></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">// Way 2:</span></span><br><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// Way 3:</span></span><br><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 将数组转换为<code>List</code>可以直接利用<code>List.of()</code>方法。<strong>注</strong>：返回的是一个只读<code>List</code>，对其调用<code>add()</code>等方法均会抛出<code>UnsupportedOperationException</code>异常。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>方法，放入的实例必须正确覆写<code>equals()</code>方法，否则将查找不到。<code>equals()</code>方法必须满足以下条件：自反性；对称性；传递性；一致性。<strong>注</strong>：编写<code>equals()</code>方法时可以借助<code>Object.equals()</code>方法判断，两个引用类型都是<code>null</code>时它们也是相等的。</p>
<p>※ 覆写<code>equals()</code>方法的一般步骤：确定哪些属性相等，就认为实例相等；利用<code>instanceof()</code>判断传入待比较的<code>Object</code>是否为当前类型，若是则继续比较，否则返回<code>false</code>；对基本类型利用<code>==</code>进行比较，对引用类型利用<code>Ibject.equals()</code>方法进行比较：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：若不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，则无需覆写<code>equals()</code>方法。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 对<code>Map</code>来说，遍历<code>Key</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>KeySet()</code>方法返回的<code>Set</code>集合；同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>方法返回的<code>Set</code>集合：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 005 -->

<p>※ <code>HashMap</code>初始化时默认的数组大小只有<code>16</code>，任何<code>key</code>，无论其<code>hashcode()</code>有多大，通过与<code>0x1f</code>进行与运算后均可将索引限制在<code>0~15</code>；当添加的<code>key</code>的数量超过<code>16</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍；相应地，需要重新借助与运算将索引限制在<code>0~31</code>。由于扩容会导致重新分布已有的<code>key-value</code>，因此对<code>HashMap</code>的性能影响很大。若事先已经确定<code>HashMap</code>的容量，更好的方式是初始化时便指定容量。</p>
<p>※ 不同<code>key</code>具有相同<code>hashcode()</code> 的情况称为<span style="color:blue">哈希冲突</span>。发生哈希冲突时，一种最简单的方法便是利用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，冲突的概率越大，<code>List</code>便越长，<code>Map</code>的<code>get()</code>方法效率便越低。</p>
<p>※ 正确使用<code>Map</code>必须保证：若实例<code>a</code>和实例<code>b</code>相等，则<code>a.equals(b)</code>必须为<code>true</code>，并且<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；反之，若实例<code>a</code>和实例<code>b</code>不等，则<code>a.equals(b)</code>必须为<code>false</code>，并且<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等，否则会出现上面那种情况。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 若<code>Map</code>的<code>key</code>为<code>enum</code>类型，则推荐使用<code>EnumMap</code>，其在内部以非常紧凑的数组存储<code>value</code>，并根据<code>enum</code>类型的<code>key</code>直接定位到内部数组的索引，无需计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 通常情况下，遍历<code>Map</code>的<code>Key</code>时顺序是不可预测的，但<code>SortedMap</code>可以。</p>
<p>※ <code>SortedMap</code>的实现类为<code>TreeMap</code>。使用<code>TreeMap</code>时，放入的<code>Key</code>必须实现<code>Comparable</code>接口；若没有实现，则在创建<code>TreeMap</code>时必须指定一个自定义排序算法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><span style="color:red"><strong>注</strong></span>：<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>方法，因为<code>TreeMap</code>利用<code>Comparable</code>进行比较！</p>
<p>※ <code>TreeMap</code>在比较两个<code>Key</code>是否相等时，依赖于<code>Key</code>的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。当两个<code>Key</code>相等时，<span style="color:red">必须</span>返回<code>0</code>；或者直接借助<code>Integer.compare(int, int)</code>方法。</p>
</blockquote>
<blockquote>
<!-- Part 008 -->

<p>※ 利用<code>Properties</code>读取配置文件共分为如下三步：创建<code>Properties</code>实例；调用<code>load()</code>方法读取文件；调用<code>getProperty()</code>获取配置：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String f = <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> java.io.FileInputStream(f));</span><br><span class="line">String filepath = props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line">String interval = props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用<code>getProperty()</code>获取配置时，若<code>Key</code>不存在，则返回<code>null</code>或者事先设定的默认值。<strong>注</strong>：可以从文件系统，<code>classpath</code>或其它任何地方读取配置文件。</p>
<p>※ 如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以利用<code>store()</code>方法将配置写入文件，方便下次读取：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 如果存在多个配置文件，则后读取的<code>key-value</code>会覆盖先读取的<code>key-value</code>。</p>
</blockquote>
<blockquote>
<!-- Part 009 -->

<p>※ <code>Set</code>相当于只存储<code>Key</code>、不存储<code>value</code>的<code>Map</code>。</p>
<p>※ 最常用的<code>Set</code>实现类为<code>HashSet</code>，它是对<code>HashMap</code>的一个简单封装。</p>
<p>※ 与<code>SortedMap</code>类似，<code>SortedSet</code>可以实现对<code>Key</code>的顺序访问。</p>
</blockquote>
<blockquote>
<!-- Part 010 -->

<p>※ <code>Queue</code>常用方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>Throw Exception</th>
<th>E or False or Null</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素到队尾</td>
<td><code>add(E e)</code></td>
<td><code>boolean offer(E e)</code></td>
</tr>
<tr>
<td>取队首元素并删除</td>
<td><code>E remove()</code></td>
<td><code>E poll()</code></td>
</tr>
<tr>
<td>取队首元素但不删除</td>
<td><code>E element()</code></td>
<td><code>E peek()</code></td>
</tr>
</tbody></table>
<p><strong>注</strong>：切忌将<code>null</code>添加到队列中，否则<code>poll()</code>方法返回<code>null</code>时，很难确定是取到了<code>null</code>元素还是队列为空。</p>
<p>※ <code>LinkedList</code>既实现了<code>List</code>接口，又实现了<code>Queue</code>接口。</p>
</blockquote>
<blockquote>
<!-- Part 011 -->

<p>※ <code>PriorityQueue</code>与<code>Queue</code>的区别在于：前者的出队顺序与元素的优先级有关，在对其调用<code>remove()</code>或<code>pull()</code>方法时，返回的总是优先级最高的元素。</p>
<p>※ 放入<code>PriorityQueue</code>中的元素，必须实现<code>Comparable</code>接口；若没有实现，则在创建<code>PriorityQueue</code>时必须提供一个<code>Comparator</code>对象：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 012 -->

<p>※ <code>Queue</code>与<code>Deque</code>出、入队方法对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>Queue</th>
<th>Deque</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素到队尾</td>
<td><code>add(E e)</code>/<code>offer(E e)</code></td>
<td><code>addLast(E e)</code>/<code>offerLast(E e)</code></td>
</tr>
<tr>
<td>取队首元素并删除</td>
<td><code>E remove()</code>/<code>E poll()</code></td>
<td><code>E removeFirst()</code>/<code>E pollFirst()</code></td>
</tr>
<tr>
<td>取队首元素但不删除</td>
<td><code>E element()</code>/<code>E peek()</code></td>
<td><code>E getFirst()</code>/<code>E peekFirst()</code></td>
</tr>
<tr>
<td>添加元素到队首</td>
<td>-</td>
<td><code>addFirst(E e)</code>/<code>offerFirst(E e)</code></td>
</tr>
<tr>
<td>取队尾元素并删除</td>
<td>-</td>
<td><code>E removeLast()</code>/<code>E pollLast()</code></td>
</tr>
<tr>
<td>取队尾元素但不删除</td>
<td>-</td>
<td><code>E getLast()</code>/<code>E peekLast()</code></td>
</tr>
</tbody></table>
<p>※ <code>Deque</code>接口的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>
</blockquote>
<blockquote>
<!-- Part 013 -->

<p>※ 在<code>Java</code>中，有个遗留类叫做<code>Stack</code>，出于兼容性考虑，并没有创建<code>Stack</code>接口，因此只能用<code>Deque</code>接口模拟<code>Stack</code>。<strong>注</strong>：当我们把<code>Deque</code>作为<code>Stack</code>使用时，只调用<code>push()</code>、<code>pop()</code>和<code>peek()</code>方法。</p>
</blockquote>
<blockquote>
<!-- Part 014 -->

<p>※ <code>Java</code>编译器并不清楚如何遍历<code>List</code>，利用<code>for each</code>循环遍历<code>List</code>之所以能够编译通过，是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>※ 使用迭代器的好处在于：调用方法总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。</p>
<p>※ 如果自己编写了一个集合类，并且想要使用<code>for each</code>循环，只需满足以下条件：集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；用<code>Iterator</code>对象迭代集合内部数据。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 在编写<code>Iterator</code>的时候，通常用一个内部类来实现<code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后通过该<code>this</code>引用访问<code>ReverseList</code>的所有字段和方法。</p>
</blockquote>
<blockquote>
<!-- Part 015 -->

<p>※ <code>Collections</code>是<code>JDK</code>提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能够更加方便地操作各种集合。</p>
<p>※ 创建空<code>List</code>：<code>List&lt;T&gt; emptyList()</code>；创建空<code>Map</code>：<code>Map&lt;K, V&gt; emptyMap()</code>；创建空<code>Set</code>：<code>Set&lt;T&gt; emptySet()</code>。<strong>注</strong>：返回的空集合为不可变集合，无法向其中添加或删除元素。此外，也可以通过各个集合接口提供的<code>of(T ...)</code>方法创建空集合。</p>
<p>※ 创建单元素<code>List</code>：<code>List&lt;T&gt; singletonList(T o)</code>；创建单元素<code>Map</code>：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code>；创建单元素<code>Set</code>：<code>Set&lt;T&gt; singleton(T o)</code>。<strong>注</strong>：返回的单元素集合同样为不可变集合，无法向其中添加或删除元素。此外，也可以通过各个集合接口提供的<code>of(T ...)</code>方法创建单元素集合。</p>
<p>※ <code>Collections</code>可以对<code>List</code>进行排序。由于排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>。</p>
<p>※ 将<code>List</code>封装成不可变集合：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code>；将<code>Map</code>封装成不可变集合：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code>；将<code>Set</code>封装成不可变集合：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code>。<strong>注</strong>：该封装实际上是通过创建一个代理拦截掉所有修改方法实现的。然而，若继续对原始可变集合进行增删，同样会影响到封装后的不可变集合。为此，如果我们希望把一个可变集合封装成不可变集合，最好在返回不可变集合后扔掉对可变集合的引用。</p>
</blockquote>
<h4 id="Day-005"><a href="#Day-005" class="headerlink" title="Day 005"></a>Day 005</h4><blockquote>
<!-- Part 001 -->

</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/24/Leetcode-06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/24/Leetcode-06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">06 动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-24 16:26:43" itemprop="dateCreated datePublished" datetime="2020-10-24T16:26:43+08:00">2020-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-21 16:04:22" itemprop="dateModified" datetime="2020-11-21T16:04:22+08:00">2020-11-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h4><blockquote>
<p>※ 建立二维数组<code>dp[s.length()][dp.length()]</code>，其中，<code>dp[i][j]</code>表示字符串第<code>i</code>个字符与第<code>j</code>个字符之间的所有字符构成的子字符串中最长回文子序列的长度（包括第<code>i</code>个字符和第<code>j</code>个字符）。易知，若<code>s.charAt(i) == s.charAt(j)</code>，则有<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>；若<code>s.charAt(i) != s.charAt(j)</code>，则有<code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</code>。基于上述递推公式，可以得知，从后往前更新<code>dp</code>更为合适。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N^2)$。</p>
</blockquote>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h4><blockquote>
<p>※ 用变量<code>not_hold[i]</code>表示第<code>i</code>天不持有股票时的利润，<code>hold[i]</code>表示第<code>i</code>天持有股票时的理论，可得如下状态转移方程：</p>
<p><code>not_hold[i] = Math.max(not_hold[i - 1], hold[i - 1] + prices[i] - fee)</code>，</p>
<p><code>hold[i] = Math.max(hold[i], not_hold[i - 1] + prices[i])</code>，</p>
<p>在初始时，有<code>not_hold[0] = 0</code>，<code>hold[0] = - prices[0]</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> not_hold = <span class="number">0</span>, hold = - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> old_hold = not_hold;</span><br><span class="line">            not_hold = Math.max(not_hold, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, old_hold - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> not_hold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a>983. 最低票价</h4><blockquote>
<p>※ 记第<code>N</code>天的最低票价为<code>F(N)</code>，假设已经求出了前<code>N - 1</code>天的最低票价，现在来求<code>F(N)</code>。如果第<code>N</code>天要选择有效期长度为<code>dayOfPass</code>的通行证，其价格为<code>cost</code>，那么在第<code>N - dayOfPass</code>天时就应该买入该通行证，才能使利益最大化；而我们已经求出了前<code>N - 1</code>天的最低票价，即<code>F(N - dayOfPass)</code>是已知的。因此，对于该选择，其花费为<code>F(N - dayOfPass) + cost</code>，取所有选择的最小值更新<code>F(N)</code>即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, n = days.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days[n - <span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[pos] == i) &#123;</span><br><span class="line">                <span class="keyword">int</span> d1 = i - <span class="number">1</span> &gt; <span class="number">0</span> ? i - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> d2 = i - <span class="number">7</span> &gt; <span class="number">0</span> ? i - <span class="number">7</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> d3 = i - <span class="number">30</span> &gt; <span class="number">0</span> ? i - <span class="number">30</span> : <span class="number">0</span>;</span><br><span class="line">                dp[i] = Math.min(dp[d1] + costs[<span class="number">0</span>], Math.min(dp[d2] + costs[<span class="number">1</span>], dp[d3] + costs[<span class="number">2</span>]));</span><br><span class="line">                pos++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(W)$，其中，<code>W</code>表示旅行计划中日期的最大值；空间复杂度：$O(W)$。</p>
</blockquote>
<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h4><blockquote>
<p>※ 该题目与<code>55. 跳跃游戏</code>类似，只是多了一个转换的过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[T + <span class="number">1</span>]; <span class="comment">// 保存以 i 为起点所能到达的最远距离。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] clip : clips) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clip[<span class="number">0</span>] &lt; T) &#123; <span class="comment">// ???</span></span><br><span class="line">                max[clip[<span class="number">0</span>]] = Math.max(max[clip[<span class="number">0</span>]], clip[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, max_n = <span class="number">0</span>, next_max_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T &amp;&amp; i&lt;= next_max_n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; max_n) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                max_n = next_max_n;</span><br><span class="line">            &#125;</span><br><span class="line">            next_max_n = Math.max(next_max_n, max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next_max_n &lt; T) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(T)$；空间复杂度：$O(T + N)$，其中，<code>T</code>表示区间的长度，<code>N</code>表示子区间的数量。</p>
</blockquote>
<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h4><blockquote>
<p>※ 该题目可以近似视为<code>0-1</code>背包问题，即将所有的石头分为两堆，并使得它们的总重相差最少（详情请见<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/you-qian-ru-shen-si-lu-ji-0-1-bei-bao-xiang-jie-mo/">解析</a>）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = dp.length - <span class="number">1</span>; i &gt;= stone; i--) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - stone] + stone); <span class="comment">// 对空间进行压缩时需要倒序遍历！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[sum / <span class="number">2</span>]; <span class="comment">// 这里是 sum - 2 * dp[sum / 2] 而不是 sum - dp[sum / 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M * N)$，其中，<code>M</code>表示石块总重，<code>N</code>表示石块的个数；空间复杂度：$O(M)$。</p>
</blockquote>
<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h4><blockquote>
<p>※ 令<code>dp[i][j]</code>表示字符串<code>S1[0:i]</code>与字符串<code>S2[0:j]</code>的最长公共子序列，则有<code>S1[i] = S2[j]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code>；<code>S1[i] != S2[j]</code>时，<code>dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = text1.length(), cols = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = text2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars1[i] == chars2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows][cols];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<h4 id="1314-矩阵区域和"><a href="#1314-矩阵区域和" class="headerlink" title="1314. 矩阵区域和"></a>1314. 矩阵区域和</h4><blockquote>
<p>※ 用二维数组<code>dp</code>表示<code>mat</code>的前缀和，其中，<code>dp[i][j]</code>表示<code>mat</code>中以<code>(0, 0)</code>为左上角，<code>(i - 1, j - 1)</code>为右下角的子矩形的元素之和。题目需要对<code>mat</code>中的每个位置，计算以<code>(i - K, j - K)</code>为左上角，<code>(i + K, j + K)</code>为右下角的子矩形的元素之和，我们可以在前缀和的帮助下，通过：</p>
<p>$sum = dp[i + K + 1][j + K + 1] - dp[i - K][j + K + 1] - dp[i + K + 1][j - K] + dp[i - K][j - K]$</p>
<p>得到元素之和。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixBlockSum(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> rows = mat.length, cols = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                dp[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(<span class="number">0</span>, i - K);</span><br><span class="line">                <span class="keyword">int</span> b = Math.min(rows - <span class="number">1</span>, i + K);</span><br><span class="line">                <span class="keyword">int</span> l = Math.max(<span class="number">0</span>, j - K);</span><br><span class="line">                <span class="keyword">int</span> r = Math.min(cols - <span class="number">1</span>, j + K);</span><br><span class="line">                res[i][j] = dp[b + <span class="number">1</span>][r + <span class="number">1</span>] + dp[t][l] - dp[b + <span class="number">1</span>][l] - dp[t][r + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/20/Java-01-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/Java-01-%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-20 20:24:36" itemprop="dateCreated datePublished" datetime="2020-10-20T20:24:36+08:00">2020-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-09 11:39:47" itemprop="dateModified" datetime="2020-11-09T11:39:47+08:00">2020-11-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Day-001"><a href="#Day-001" class="headerlink" title="Day 001"></a>Day 001</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>Java</code>是一种介于编译型与解释型之间的语言，在将其源码编译成一种类似于抽象CPU指令的字节码后，通过虚拟机加载并执行，即可实现“一次编译，到处运行”的效果。<strong>注</strong>：SUN公司制定了一系列的虚拟机规范，但是从实践的角度来看，<code>JVM</code>的兼容性做得最好，低版本的<code>Java</code>字节码完全可以在高版本的<code>JVM</code>上运行。</p>
<p>※ 简单来说，<code>JRE(Java Runtime Environment)</code>是<code>Java</code>的运行环境，包含了<code>JVM</code>标准实现及<code>Java</code>核心类库；<code>JDK(Java Development Kit)</code>是<code>Java</code>的开发工具包，既包含了<code>Java</code>的运行环境，又包含了<code>Java</code>的编译环境。它们之间的关系如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─    ┌──────────────────────────────────┐</span><br><span class="line">│     │     Compiler, debugger, etc.     │</span><br><span class="line">│     └──────────────────────────────────┘</span><br><span class="line">JDK┌─ ┌──────────────────────────────────┐</span><br><span class="line">│  │  │                                  │</span><br><span class="line">│ JRE │      JVM + Runtime Library       │</span><br><span class="line">│  │  │                                  │</span><br><span class="line">└─ └─ └──────────────────────────────────┘</span><br><span class="line">┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">│Windows││ Linux ││ macOS ││others │</span><br><span class="line">└───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 002 -->

<p>※ 在<code>JAVA_HOME</code>的<code>bin</code>目录下存在很多可执行文件，其中：<code>java</code>用于解析字节码文件使其得到运行；<code>javac</code>用于将源码文件编译为字节码文件；<code>javadoc</code>用于从源码文件中自动提取注释并生成文档；<code>jar</code>用于将一组字节码文件打包成一个<code>.jar</code>文件，便于发布；<code>jdb</code>用于开发阶段的运行调试。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>Java</code>程序总是从<code>public static void main(String[] args)</code>方法开始执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java 程序规定的方法必须为静态方法，方法名必须为 main，方法内的参数必须为 String 数组。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, chen!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 一个源码文件<span style="color:red">只能</span>定义一个<code>public</code>类型的<code>class</code>，并且<code>class</code>名称要和文件名完全一致。</p>
</blockquote>
<h4 id="Day-002"><a href="#Day-002" class="headerlink" title="Day 002"></a>Day 002</h4><blockquote>
<!-- Part 001 -->

<p>※ 基本数据类型是指CPU可以直接进行运算的类型，<code>Java</code>定义了以下几种基本数据类型：整数类型，包括<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>；浮点数类型，包括<code>float</code>、<code>double</code>；字符类型，包括<code>char</code>；布尔类型，包括<code>boolean</code>。<strong>注</strong>：理论上存储布尔类型只需要一位，但是<code>JVM</code>内部通常会把<code>boolean</code>表示为<span style="color:red"><code>4</code></span>字节整数。除上述基本数据类型外，其余变量均属于引用类型，包括最常用的<code>String</code>字符串。</p>
<p>※ 可以使用<code>final</code>关键字来定义常量：<code>final double PI = 3.14</code>。常量一经定义，便不可再次赋值。</p>
<p>※ 若变量类型的名字太长，写起来比较麻烦，可以使用<code>var</code>关键字：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译器会根据赋值语句自动推断出变量<code>sb</code>的类型为<code>StringBuilder</code>。因此，使用<code>var</code>定义变量，仅仅是少写了变量类型而已。</p>
<p>※ 定义变量时，应遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且最好不要重复使用变量名。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 整数的数值表示不但是精确的，而且运算也是精确的。<strong>注</strong>：除数为<code>0</code>在编译时并不会报错，在运行时才会报错。此外，溢出不会报错！</p>
<p>※ 利用右移运算符<code>&gt;&gt;</code>对一个<span style="color:red">负数</span>进行右移操作时，高位总是补<code>1</code>；利用右移运算符<code>&gt;&gt;&gt;</code>对<span style="color:red">整数</span>进行右移操作时，高位总是补<code>0</code>。<strong>注</strong>：对<code>byte</code>和<code>short</code>进行移位时，首先会将它们转换为<code>int</code>。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时不会报错，只是会返回几个特殊值：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN: Not a Number</span></span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity: 无穷大</span></span><br><span class="line"><span class="keyword">double</span> d3 = -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity: 无穷小</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 可以将浮点数强制转换为整数。转换后，浮点数的小数部分将<span style="color:red">被舍弃</span>，若整数部分超过了整型能表示的最大范围，将返回整型的最大值。<strong>注</strong>：若想要四舍五入，只需在转换前为浮点数加<code>0.5</code>即可。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ <code>Java</code>中的三元运算符为<code>b ? x : y</code>；<code>Python</code>中的三元运算符为：<code>x if b else y</code>。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <code>Java</code>在内存中总是使用<code>Unicode</code>表示字符。关于<code>Unicode</code>和<code>UTF-8</code>之间的关系，可以自行参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456">讲解</a>。</p>
<p>※ 在使用<code>+</code>连接任意字符串和其它数据类型时，编译器会先将其它数据类型转换为字符串，之后再进行连接。</p>
<p>※ 引用类型的变量可以指向一个空值<code>null</code>，它表示该变量不指向任何对象。<strong>注</strong>：要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，后者属于有效的字符串对象。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 数组初始化存在如下三种方式：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] ns = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：数组属于引用类型，并且一旦创建后大小便不可变。</p>
</blockquote>
<h4 id="Day-003"><a href="#Day-003" class="headerlink" title="Day 003"></a>Day 003</h4><blockquote>
<!-- Part 001 -->

<p>※ 通过使用占位符<code>%?</code>，<code>System.out.printf()</code>可以把参数格式化成指定格式。常见的占位符有：<code>%d</code>，格式化输出整数；<code>%x</code>，格式化输出十六进制整数；<code>%f</code>，格式化输出浮点数；<code>%e</code>，格式化输出科学计数法表示的浮点数；<code>%s</code>，格式化输出字符串。<strong>注</strong>：一个<code>%</code>表示占位符，两个<code>%%</code>表示<code>%</code>本身。关于格式化参数的更多信息，可以自行参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax">文档</a>。</p>
<p>※ 从控制台读取字符串及整数的通用流程：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 导入 java.util.Scanner</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// Step 2: 创建 Scanner 对象并传入 System.in</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">// Step 3: 读取用户输入的字符串</span></span><br><span class="line">String name = scanner.nextLine();</span><br><span class="line"><span class="comment">// Step 4: 读取用户输入的整数</span></span><br><span class="line"><span class="keyword">int</span> age = scanner.nextInt();</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 002 -->

<p>※ 要判断引用类型的变量是否相等，必须使用<code>equals()</code>，因为<code>==</code>此时仅用于判断变量是否指向同一个对象。<strong>注</strong>：执行语句<code>s1.equals(s2)</code>时，若变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code>。为避免这一错误，可以借助短路运算符<code>&amp;&amp;</code>：<code>s1 != null &amp;&amp; s1.equals(s2)</code>。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 使用<code>switch</code>时，<code>case</code>语句后面不需要接<code>&#123;&#125;</code>。</p>
<p>※ 从<code>Java 12</code>开始，<code>switch</code>升级为更简洁的表达式语法，保证只有一条路径会被执行，并且不需要<code>break</code>语句：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String fruit = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">    <span class="comment">// 若要执行多条语句，需要在 case 语句后面接 &#123;&#125;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：<code>Java 12</code>只是引入了<code>Switch</code>表达式作为预览特性；<code>Java 13</code>对该特性进行了修改，并且引入了<code>yield</code>语句，用于返回值；直到<code>Java 14</code>，这一功能才正式作为标准功能提供出来。</p>
</blockquote>
<h4 id="Day-004"><a href="#Day-004" class="headerlink" title="Day 004"></a>Day 004</h4><blockquote>
<!-- Part 001 -->

<p>※ 打印一维数组存在如下三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">// Way 1:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Way 2:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n: ns) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Way 3:</span></span><br><span class="line">System.out.println(Arrays.toString(ns));</span><br></pre></td></tr></table></figure>

<p>※ 打印二维数组存在如下两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Way 1:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] arr: ns) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: arr) &#123;</span><br><span class="line">        System.out.print(n);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Way 2:</span></span><br><span class="line">System.out.println(Arrays.deepToString(ns));</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Day-005"><a href="#Day-005" class="headerlink" title="Day 005"></a>Day 005</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>Person chen</code>用于定义<code>Person</code>类型的变量<code>chen</code>，<code>new Person()</code>用于创建<code>Person</code>实例。</p>
<p>※ 可变参数兼容数组类参数，而数组类参数不兼容可变参数。关于可变参数，可以自行参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuitian/p/12274443.html">博客</a>。</p>
<p>※ 引用类型参数的传递，调用方和接收方的参数变量指向的是同一个对象，任意一方对变量进行修改，都会影响另一方。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 没有在构造方法中初始化字段时，基本数据类型的字段用默认值，引用类型的字段用<code>null</code>。</p>
<p>※ 创建对象实例时，将先会对字段进行初始化，如<code>String name = &quot;chen&quot;</code>；然后对构造方法进行初始化。</p>
<p>※ 一个构造方法可以调用其它构造方法，这样做的目的是便于代码复用。调用其它构造方法的语法为：<code>this(...)</code>。</p>
<p>※ 若自定义了构造方法，编译器将不再自动创建默认构造方法；若想要既能使用带参数的构造方法，又想要保留不带参数的构造方法，只能将两个构造方法都定义出来。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 方法<span style="color:blue">重载</span>是指方法的方法名相同，但参数不同。<strong>注</strong>：与方法的返回类型无关。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 子类将自动获得父类所有字段，<span style="color:red">严禁</span>定义与父类重名的字段。</p>
<p>※ 在定义类时，若没有明确指明所继承的类，编译器将会自动为其加上<code>extends Object</code>。</p>
<p>※ 子类无法继承父类中被<code>private</code>修饰的字段，为此，可以将<code>private</code>修改为<code>protected</code>。</p>
<p>※ 若父类没有默认的构造方法，那么子类必须显示调用<code>super()</code>并给出参数，以便编译器定位到父类中合适的构造方法。<strong>注</strong>：子类默认的构造方法是编译器自动生成而非从父类中继承的。</p>
<p>※ 将子类类型的实例赋值给父类变量，称为<span style="color:blue">向上转型</span>；将父类类型的实例强制赋值给子类变量，称为<span style="color:blue">向下转型</span>。由于子类类型的功能比父类类型多，因此向下转型很可能会失败。为了避免出错，可以借助<code>instanceof</code>操作符，该操作符用于判断变量所指向的实例是否为指定类型或指定类型的子类。<strong>注</strong>：若一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ 方法<span style="color:blue">覆写</span>是指子类定义了一个与父类方法签名和返回类型完全相同的方法。</p>
<p>※ <code>@override</code>注解可以让编译器帮忙检查是否进行了正确的覆写。<strong>注</strong>：<code>@override</code>不是必需的。</p>
<p>※ 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
<p>※ 在子类的覆写方法中，可以通过<code>super</code>来调用父类被覆写的方法。</p>
<p>※ 被<code>final</code>修饰的方法不能被覆写，被<code>final</code>修饰的类不能被继承。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 若父类方法本身不需要实现任何功能，只是为了定义方法以令子类覆写，那么可以把父类方法声明为抽象方法：<code>public abstract void run()</code>。</p>
<p>※ 若某个类中包含了抽象方法，那么必须把该类也声明为<code>abstract</code>，才能正确编译它。<strong>注</strong>：我们无法实例化一个抽象类。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 若一个抽象类中没有字段，所有方法均为抽象方法，那么可以将该抽象类改写为接口：<code>interface</code>。<strong>注</strong>：一个类只能继承自另一个类，但可以继承多个接口。</p>
<p>※ 当我们需要给接口新增一个方法时，若新增的方法为<code>default</code>方法，那么实现了该接口的子类无需全部修改，只需在需要覆写的地方去覆写新增方法即可。</p>
<p>※ 抽象类与接口之间的区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td align="center">只能<code>extends</code>一个<code>class</code></td>
<td align="center">可以<code>implements</code>多个<code>interface</code></td>
</tr>
<tr>
<td align="center">字段</td>
<td align="center">可以定义实例字段</td>
<td align="center">不能定义实例字段</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td align="center">可以定义抽象方法</td>
<td align="center">可以定义抽象方法</td>
</tr>
<tr>
<td align="center">非抽象方法</td>
<td align="center">可以定义非抽象方法</td>
<td align="center">可以定义<code>default</code>方法</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<!-- Part 008 -->

<p>※ 利用<code>static</code>修饰的字段，称为静态字段。对于静态字段，类的所有实例都会共享它。</p>
<p>※ 利用<code>static</code>修饰的方法，称为静态方法。<strong>注</strong>：由于静态方法属于类而不属于实例，因此其内部无法访问实例字段，也无法访问<code>this</code>变量，<span style="color:red">只能</span>访问静态字段。</p>
<p>※ 接口可以定义静态字段，而且静态字段必须为<code>final</code>类型。由于接口的字段只能是<code>public static final</code>类型，因此可以将这些修饰符都去掉。</p>
</blockquote>
<blockquote>
<!-- Part 009 -->

<p>※ 包主要用于解决类名冲突。</p>
<p>※ 包可以是多层结构，用<code>.</code>隔开。<strong>注</strong>：<code>java.util</code>和<code>java.util.zip</code>之间没有任何继承关系。</p>
<p>※ 位于同一个包的类，可以访问包作用域的字段和方法。其中，<span style="color:blue">包作用域</span>是指一个类允许访问同一个包中没有被<code>public</code>、<code>private</code>修饰的类，以及没有被<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>
<p>※ 当编译器遇到一个类名时，若该类名为完整类名，则会直接根据完整类名查找；若该类名为简单类名，则会按照如下顺序依次查找：当前<code>package</code>；<code>import</code>的包；<code>java.lang</code>中的包。<strong>注</strong>：编写类时，编译器会自动帮我们做两个<code>import</code>的动作：自动<code>import</code>当前包的其它类；自动<code>import java.lang.*</code>。</p>
</blockquote>
<blockquote>
<!-- Part 010 -->

<p>※ 定义为<code>public</code>的类和接口可以被其它任何类访问；定义为<code>public</code>的字段和方法可以被其它类访问，前提是有访问类的权限。</p>
</blockquote>
<blockquote>
<!-- Part 011 -->

<p>※ <code>Java</code>的内部类可以分为<code>Inner Class</code>、<code>Anonymous Class</code>和<code>Static Nested Class</code>。其中，<code>Inner Class</code>和<code>Anonymous Class</code>本质上是相同的，都必须依附于<code>Outer Class</code>的实例，即隐含地持有<code>Outer.this</code>实例，并拥有<code>Outer Class</code>的<code>private</code>访问权限；<code>Static Nested Class</code>为独立类，不依附于<code>Outer Class</code>的实例，但拥有<code>Outer Class</code>的<code>private</code>访问权限。</p>
</blockquote>
<blockquote>
<!-- Part 012 -->

<p>※ <code>classpath</code>是一组目录的集合，用于指示<code>JVM</code>搜索<code>.class</code>的路径及顺序。</p>
<p>※ <code>classpath</code>的设置方式有两种：在系统环境变量中设置；在启动<code>JVM</code>时设置。不推荐前者，因为那样会污染整个系统环境。利用后者设置<code>classpath</code>的方式如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project\bin;C:\sgared abc.xyz.Hello</span><br><span class="line">java -cp .;C:\work\project\bin;C:\sgared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么<code>JVM</code>默认的<code>classpath</code>为<code>.</code>，即当前目录。</p>
<p>※ <code>jar</code>用于将<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其它文件）都打包成一个<code>jar</code>文件。</p>
<p>※ <code>jar</code>可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>纯文本文件，用于提供基本信息，如<code>Main-Class</code>，这样可以直接运行<code>jar</code>。</p>
</blockquote>
<blockquote>
<!-- Part 013 -->

<p>※ <code>jar</code>只是存放<code>.class</code>的容器，但是并不关心它们之间的依赖，从<code>Java 9</code>开始引入的模块便是为了解决依赖这一问题。<strong>注</strong>：模块的后缀名为<code>jmod</code>。</p>
<p>※ 将一堆<code>class</code>封装为<code>jar</code>只是一个打包的过程，而把一堆<code>class</code>封装为模块不但需要打包，还需将依赖关系写入至<code>module-info.java</code>中，并且还可以包含二进制代码（通常是<code>JNI</code>扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的<code>JVM</code>提供不同的版本。</p>
<p>※ 利用模块，可以按需打包<code>jre</code>。关于如何编写模块，运行模块及打包<code>JRE</code>，可以自行参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">这里</a>。</p>
</blockquote>
<h4 id="Day-006"><a href="#Day-006" class="headerlink" title="Day 006"></a>Day 006</h4><blockquote>
<!-- Part 001 -->

<p>※ 字符串在<code>String</code>内部实际上是通过一个<code>char[]</code>数组表示的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;n&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只是因为字符串太常用了，所以提供了<code>&quot;...&quot;</code>这种字面量表示方法。</p>
<p>※ 字符串的不可变性是通过内部的<code>private final char[]</code>属性以及没有任何修改<code>char[]</code>的方法实现的。</p>
<p>※ 若想比较两个字符串是否相同，必须使用<code>equals()</code>方法而不能用<code>==</code>！<strong>注</strong>：若要忽略大小写比较，可以使用<code>equalsIgnoreCase()</code>方法。</p>
<p>※ <code>trim()</code>和<code>strip()</code>均可以用于移除字符串首位空白字符，只是后者还会将类似中文的空格字符<code>\u3000</code>移除。<strong>注</strong>：空白字符包括<code>\t</code>、<code>\r</code>、<code>\n</code>。</p>
<p>※ <code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是将该字符串对应的系统变量转换为<code>Integer</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，15</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ <code>String</code>和<code>char[]</code>可以相互转换，对<code>char[]</code>进行修改，并不会影响到<code>String</code>，这是因为在通过<code>new String(char[])</code>创建<code>String</code>实例时，并不会直接引用传入的<code>char[]</code>数组，而是会复制一份。<strong>注</strong>：从<code>String</code>的不变性设计可以看出，若传入的对象有可能发生改变，我们需要复制而不是直接引用。</p>
<p>※ 对于不同版本的<code>JDK</code>，<code>String</code>在内存中有着不同的优化方式。具体来说，早期<code>JDK</code>版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而较新<code>JDK</code>版本则以<code>byte[]</code>存储：若<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则每两个<code>byte</code>存储一个字符。这样做的目的是节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 002 -->

<p>※ 虽然可以直接利用<code>+</code>拼接字符串，但是，每次拼接都会创建新的字符串对象并扔掉旧的字符串，这样将会导致绝大部分字符串都是临时对象，不但浪费内存，还会影响垃圾回收效率。为了能够提高拼接效率，<code>Java</code>标准库提供了一个可以预分配缓冲区的可变对象<code>StringBuilder</code>，这样，在往<code>StringBuidler</code>中新增字符时，将不会创建新的临时对象。<strong>注</strong>：<code>StringBuilder</code>支持链式操作，实现链式操作的关键是返回实例本身。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 用指定分隔符拼接字符串数组时，可以借助<code>StringJoiner</code>或者<code>String.join()</code>。与<code>String.join()</code>相比，<code>StringJoiner</code>可以额外附加一个“开头”和“结尾”。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 直接将基本类型转型为引用类型的赋值写法称为<span style="color:blue">自动装箱</span>，将引用类型转型为基本类型的赋值写法称为<span style="color:blue">自动拆箱</span>。<strong>注</strong>：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
<p>※ 在<code>Java</code>中，无符号整型和有符号整型的转换需要借助包装类型的静态方法完成。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ 在<code>Java</code>中，有很多<code>class</code>的定义都符合这样的规范：若干<code>private</code>属性；通过<code>public</code>方法读写属性。例如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Type value)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的<code>class</code>被称为<code>JavaBean</code>。</p>
<p>※ 要枚举一个<code>JavaBean</code>的所有属性，可以直接使用<code>Java</code>核心库提供的<code>Introspector</code>，示例请参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">这里</a>。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>TODO：没看懂。。。</p>
<p>※ 使用<code>enum</code>定义的枚举类属于引用类型，按理说在对引用类型进行比较时需要使用<code>equals()</code>方法，但枚举类例外，其每个常量在<code>JVM</code>中只有一个唯一实例，因此可以直接利用<code>==</code>比较。</p>
<p>※ 与常量相比，使用<code>enum</code>定义枚举有如下好处：首先，<code>enum</code>常量本身带有类型信息，编译器会自动检查出类型错误；其次，无法引用到非枚举的值；最后，不同类型的枚举不能互相比较或赋值。</p>
<p>※ 与普通类相比，枚举类有如下特点：总是继承自<code>java.lang.Enum</code>，且无法被继承；只能定义出<code>enum</code>的实例，无法通过<code>new</code>操作符创建<code>enum</code>的实例；定义的每个类都是引用类型的唯一实例；可以将枚举类用于<code>switch</code>语句。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 从<code>Java 14</code>开始，提供了新的<code>record</code>关键字，用于定义不变类。<strong>注</strong>：通过编写<code>Compact Constructor</code>，可以对参数进行验证；通过定义静态方法，可以更加便捷的创建不变类。</p>
</blockquote>
<blockquote>
<!-- Part 008 -->

<p>※ <code>Java.math.BigInteger</code>用于表示任意大小的整数，其内部用一个<code>int[]</code>来进行模拟。</p>
<p>※ 我们可以将<code>BigInteger</code>转换为基本类型，若其表示的数值超过了基本类型的范围，将丢失高位信息。若想要将其准确地转换为基本类型，可以使用<code>intValueExact()</code>等方法，这样，在数值超出基本类型的范围时，将抛出<code>ArithmeticException</code>异常。<strong>注</strong>：若<code>BigInteger</code>的数值超过了<code>float</code>的最大范围，<code>floatValue()</code>将会返回<code>Infinity</code>。</p>
</blockquote>
<blockquote>
<!-- Part 009 -->

<p>※ <code>Java.math.BigDecimal</code>用于表示任意大小并且精度完全准确的浮点数。</p>
<p>※ <code>scale()</code>方法可以获取<code>BigDecimal</code>的小数位数；<code>setScale()</code>方法可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，若精度比原始值低，将按照指定的方法进行四舍五入或直接截断；<code>stripTrailingZeros()</code>方法，可以将<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾<code>0</code>的<code>BigDecimal</code>。<strong>注</strong>：若一个<code>BigDecimal</code>的<code>scale()</code>返回负数，如<code>-2</code>，表示这个数为整数，并且末尾有<code>2</code>个<code>0</code>。</p>
<p>※ 对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，此时可以利用<code>divideAndRemainder()</code>方法分别获取商和余数，或者指定精度以及如何进行截断。</p>
<p>※ 在比较两个<code>BigDecimal</code>的大小时，建议使用<code>compareTo()</code>方法，而非<code>equals()</code>，因为前者可以忽略多余的<code>0</code>。</p>
</blockquote>
<blockquote>
<!-- Part 010 -->

<p>※ <code>Math</code>类用于进行数学计算，其与<code>StrictMath</code>类的区别在于：前者会尽量针对平台优化计算速度；后者会保证浮点数计算在所有平台上的结果都是相同的。</p>
</blockquote>
<h4 id="Day-007"><a href="#Day-007" class="headerlink" title="Day 007"></a>Day 007</h4><blockquote>
<!-- Part 001 -->

<p>※ 所有的<code>Java</code>异常均继承自<code>Throwable</code>，它们共分为两个体系：<code>Error</code>和<code>Exception</code>。其中，<code>Error</code>属于无需捕获的严重错误；<code>Exception</code>属于可以被捕获并处理的错误，并可进一步被细分为<code>RuntimeException</code>和非<code>RuntimeException</code>两大类。<strong>注</strong>：<code>Java</code>规定，必须捕获的异常包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类（该类异常被称为<code>Checked Exception</code>）；不必须捕获的异常包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
<p>※ 所有的异常都可以调用<code>printStackTrace()</code>方法打印异常栈。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ 使用<code>try ... catch ... finally</code>时，一个<code>catch</code>语句可以匹配多个非继承关系的异常：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException | NumberFormatException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 003 -->

<p>※ 抛出异常分为两步：创建某个<code>Exception</code>实例；用<code>throw</code>语句抛出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// NullPointerException e = new NullPointerException();</span></span><br><span class="line">        <span class="comment">// throw e;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 为了能追踪到完整的异常栈，在构造异常时，可以把原始的<code>Exception</code>实例传入，这样，新的<code>Exception</code>将持有原始<code>Exception</code>信息：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">        	process2();</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.IllegalArgumentException: java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">	at Main.process1(Main.java:15)</span></span><br><span class="line"><span class="comment">	at Main.main(Main.java:5)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">	at Main.process2(Main.java:20)</span></span><br><span class="line"><span class="comment">	at Main.process1(Main.java:13)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 在<code>catch</code>中抛出异常，<code>JVM</code>会先执行<code>finally</code>，然后再抛出。<strong>注</strong>：通常不会再在<code>finally</code>中抛出异常，若一定要抛，应先用变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>将其添加进来，最后在<code>finally</code>中抛出：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 004 -->

<p>※ 自定义异常体系时，推荐从<code>RuntimeException</code>派生根异常，再派生业务异常。<strong>注</strong>：自定义异常时，应提供多种构造方法。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ 断言是一种调试方式，只能在开发和测试阶段启用，其在失败时会抛出<code>AssertionError</code>。<strong>注</strong>：断言很少被使用，更好的方法是编写单元测试。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/28/Leetcode-04-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/28/Leetcode-04-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">04 字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-28 11:13:28" itemprop="dateCreated datePublished" datetime="2020-09-28T11:13:28+08:00">2020-09-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-16 21:06:47" itemprop="dateModified" datetime="2020-11-16T21:06:47+08:00">2020-11-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><hr>
<h4 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h4><blockquote>
<p>※ 借助双指针，该题目便能够轻松解决。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= haystack.length() - needle.length() &amp;&amp; haystack.charAt(i) != needle.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; haystack.length() - needle.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; i + needle.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(j) != needle.charAt(j - i)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == i + needle.length() &amp;&amp; haystack.charAt(j - <span class="number">1</span>) == needle.charAt(needle.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：最坏为$O((N-L)L)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h4><blockquote>
<p>※ 该题目很容易能够想到通过利用<code>Map</code>建立两个字符之间的映射关系来进行解决。需要注意的是，这种映射关系应具有对称性，如<code>ab</code>、<code>cc</code>便不具有对称性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        Map&lt;Character, Character&gt; rmap = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(s.charAt(i)) != t.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(s.charAt(i), t.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rmap.containsKey(t.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rmap.get(t.charAt(i)) != s.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rmap.put(t.charAt(i), s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：该题目也可以利用“第三者”建立两个字符串之间的一一对应关系，后面有时间可以试一下。</p>
</blockquote>
<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h4><blockquote>
<p>※ 换句话说，该题目是想让我们判断两个字符串中每个字符出现的次数是否相等，我们只需计算两个字符串中每个字符出现的次数并进行比较即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            counter[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            counter[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：若数组的字符串包含<code>Unicode</code>字符，只需将<code>counter</code>设置为<code>Map</code>即可。</p>
</blockquote>
<h4 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h4><blockquote>
<p>※ 该题目与<code>205. 同构字符串</code>极为类似，在此不进行赘述。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        String[] str = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pattern.length() != str.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;Character, String&gt;();</span><br><span class="line">        Map&lt;String, Character&gt; rmap = <span class="keyword">new</span> HashMap&lt;String, Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(pattern.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.get(pattern.charAt(i)).equals(str[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(pattern.charAt(i), str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rmap.containsKey(str[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rmap.get(str[i]) != pattern.charAt(i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rmap.put(str[i], pattern.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h4><blockquote>
<p>※ 首先，遍历字符串，将字符串中的每个字符及其出现的次数保存至<code>Map</code>中；然后，再次遍历字符串，并判断当前遍历字符是否只出现一次，若是，则返回当前下标；若始终没有找到只出现一次的字符，则返回<code>-1</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h4><blockquote>
<p>※ 该题目与<code>136. 只出现一次的数字</code>类似，均利用了异或的以下性质：任何数和自身进行异或运算均为<code>0</code>；任何数和<code>0</code>进行异或运算均为自身；异或运算满足交换律。只是没有想到的是，字符居然也能进行异或运算。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符串也是可以进行异或运算(^)的</span></span><br><span class="line">        <span class="keyword">char</span> res = t.charAt(t.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res ^= s.charAt(i);</span><br><span class="line">            res ^= t.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h4><blockquote>
<p>※ 在解决该题目时，上来直接调用了<code>s.split(&quot; &quot;).length</code>，得到了错误结果。阅读<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/solution/zi-fu-chuan-zhong-de-dan-ci-shu-by-leetcode/">题解</a>后得知，该题目存在一些边缘情况，如：开头或结尾存在一个或多个空格，这需要我们事先调用<code>trim()</code>函数将它们剔除；在单词之间可能存在一个以上的空格，调用<code>split()</code>函数时将会得到多个空字符<code>&quot;&quot;</code>，这需要我们利用正则表达式将它们剔除。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 原来 split() 函数中也可以使用正则表达式。</span></span><br><span class="line">            <span class="comment">// 注：这里是 \\s+ 而不是 //s+</span></span><br><span class="line">            <span class="keyword">return</span> s.split(<span class="string">&quot;\\s+&quot;</span>).length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：如果是用<code>Python</code>做，这道题只需要一行代码：<code>return len(s.split())</code>。</p>
</blockquote>
<h4 id="709-转换成小写字母"><a href="#709-转换成小写字母" class="headerlink" title="709. 转换成小写字母"></a>709. 转换成小写字母</h4><blockquote>
<p>※ 没什么可说的，遍历字符串中的每个字符，若当前字符为大写字母，将其转换为小写字母即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                sb.append(String.valueOf((<span class="keyword">char</span>) (c + <span class="number">32</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(String.valueOf(c));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771. 宝石与石头"></a>771. 宝石与石头</h4><blockquote>
<p>※ 首先，遍历字符串<code>J</code>，并利用哈希集合存储其中的每个字符；然后，遍历字符串<code>S</code>，判断其中的每个字符是否出现在哈希集合中，若出现，则是宝石。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; J.length(); i++) &#123;</span><br><span class="line">            set.add(J.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(S.charAt(i))) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M+N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="821-字符的最短距离"><a href="#821-字符的最短距离" class="headerlink" title="821. 字符的最短距离"></a>821. 字符的最短距离</h4><blockquote>
<p>※ 首先，从左向右遍历字符串，记录上一个字符<code>C</code>出现的位置<code>pre</code>，并记录<code>i - pre</code>；然后，从右向左遍历字符串，记录下一个字符<code>C</code>出现的位置<code>post</code>，并记录<code>post - i</code>；则字符的最短距离即为<code>Math.min(i - pre, post - i)</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> pre = -<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) &#123;</span><br><span class="line">                pre = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = i - pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> post = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) &#123;</span><br><span class="line">                post = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = Math.min(res[i], post - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a>844. 比较含退格的字符串</h4><blockquote>
<p>※ 首先能想到的方法便是利用栈进行解决，在查看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">题解</a>之后，发现可以借助双指针将空间复杂度优化至<code>O(1)</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = S.length() - <span class="number">1</span>, j = T.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    p--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T.charAt(j) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M + N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a>925. 长按键入</h4><blockquote>
<p>※ 由<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/long-pressed-name/solution/chang-an-jian-ru-by-leetcode-solution/">题解</a>知，字符串<code>typed</code>中的每个字符，有且只有两种用途：（1）作为<code>name</code>字符串的一部分，此时会匹配<code>name</code>中的一个字符；（2）作为长按键入的一部分，此时应与前一个字符相同。若<code>typed</code>中存在一个字符使得以上两个条件均不满足，则应当直接返回<code>false</code>；否则，当<code>typed</code>扫描完毕后，再检查<code>name</code>中的每个字符是否都被匹配了即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLongPressedName</span><span class="params">(String name, String typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里只需要判断 j 是否小于 typed.length() 即可，无需再判断 i 是否小于 name.length()。</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; typed.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; typed.charAt(j - <span class="number">1</span>) == typed.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里不应该直接返回 true，而是应该判断 i 是否已经遍历完了 name 中所有的字符。</span></span><br><span class="line">        <span class="comment">// 若直接返回 true，则测试用例 name = pyplrz，typed = ppyypllr 将会返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> i == name.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M + N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<hr>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h4><blockquote>
<p>※ 首先，利用<code>trim()</code>函数和<code>split(&quot;\\s+&quot;)</code>函数剔除首尾冗余的空格和单词之间冗余的空格；然后，借助<code>StringBuilder</code>对字符串数组进行反转拼接，没拼接完一个单词后在后面加上分隔用的空格；最后，将结尾处冗余的空格剔除。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] str = s.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(str.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            res.append(str[i]);</span><br><span class="line">            res.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h4><blockquote>
<p>※ 对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于<code>A = 1axxx</code>，<code>B = 1bxxx</code>，若<code>a &gt; b</code>，则<code>A &gt; B</code>。基于此，可以得知，若要使剩下的数字最小，需要保证靠前的数字尽可能小。给定一个长度为<code>n</code>的数字序列$[D_0D_1D_2…D_{n-1}]$，从左往右找到第一个位置<code>i (i &gt; 0)</code>，使得$D_i &lt; D_{i-1}$，并删去$D_{i-1}$；如果不存在，说明整个数字序列单调不减，删去最后一个数字即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 对于每个数字，如果该数字小于栈顶元素，我们就不断弹出栈顶元素，直到：</span></span><br><span class="line">            <span class="comment">// 栈为空；已经删除了 k 位数字；新的栈顶元素不大于当前数字</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; count &lt; k &amp;&amp; queue.peekLast() &gt; c) &#123; <span class="comment">// not &quot;queue.peekLast() &gt;= c&quot;</span></span><br><span class="line">                queue.pollLast();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offerLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上述过程结束后还需要针对一些情况做额外的处理：</span></span><br><span class="line">        <span class="comment">// 删除了 m 个数字并且 m &lt; k，这种情况下需要从序列尾部删除额外的 k - m 个数字；</span></span><br><span class="line">        <span class="comment">// 最终的数字序列存在前导零，这种情况下需要删除前导零；</span></span><br><span class="line">        <span class="comment">// 最终的数字序列为空，这种情况下应该返回 0.</span></span><br><span class="line">        <span class="comment">// while (!queue.isEmpty() &amp;&amp; count &lt; k) &#123; // num 的长度小于 10002 且 ≥ k</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() == <span class="string">&#x27;0&#x27;</span> &amp;&amp; leadingZero) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leadingZero = <span class="keyword">false</span>;</span><br><span class="line">                sb.append(queue.pollFirst());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="539-最小时间差"><a href="#539-最小时间差" class="headerlink" title="539. 最小时间差"></a>539. 最小时间差</h4><blockquote>
<p>※ 将时间全部转换为分钟制，然后对它们进行排序。<strong>注</strong>：不要忘记第一个时间和最后一个时间之间的差值！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = timePoints.size();</span><br><span class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String time = timePoints.get(i);</span><br><span class="line">            times[i] = (time.charAt(<span class="number">0</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">600</span> + (time.charAt(<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">60</span> + (time.charAt(<span class="number">3</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + time.charAt(<span class="number">4</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(times);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1440</span> - times[n - <span class="number">1</span>] + times[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res = Math.min(res, times[i + <span class="number">1</span>] - times[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：取决于内部函数；空间复杂度：取决于内部函数。</p>
</blockquote>
<h4 id="1324-竖直打印单词"><a href="#1324-竖直打印单词" class="headerlink" title="1324. 竖直打印单词"></a>1324. 竖直打印单词</h4><blockquote>
<p>※ 首先，对字符串进行分词，并统计所有单词的最大长度；然后，对于结果链表中的第<code>i</code>个元素，依次遍历所有单词，若单词存在第<code>i</code>个字符，则将该字符加入元素的末尾，否则，将空格加入元素的末尾； 最后，借助特殊方法去掉元素末尾冗余的空格即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">printVertically</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wordMaxLen = <span class="number">0</span>;</span><br><span class="line">        String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            wordMaxLen = Math.max(wordMaxLen, word.length());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordMaxLen; i++) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = i &gt;= word.length() ? <span class="string">&#x27; &#x27;</span> : word.charAt(i);</span><br><span class="line">                sb.append(c); <span class="comment">// 原来 StringBuilder 可以直接 append 字符。</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sb.toString().trim().substring(<span class="number">1</span>)); <span class="comment">// 是 substring 不是 subString !</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N max(|S|))$，其中，<code>N</code>表示单词的个数，<code>max(|S|)</code>表示最长的单词长度；空间复杂度：$O(N max(|S|))$。</p>
</blockquote>
<h4 id="1451-重新排列句子中的单词"><a href="#1451-重新排列句子中的单词" class="headerlink" title="1451. 重新排列句子中的单词"></a>1451. 重新排列句子中的单词</h4><blockquote>
<p>※ 首先，利用<code>split(&quot; &quot;)</code>函数对字符串进行分割得到单词数组；接着，利用<code>toLowerCase()</code>函数将单词数组的第一个元素进行小写化；然后，利用<code>Arrays.sort()</code>函数对单词列表进行排序；最后，将排序后的第一个元素的首字母转换为大写，并对字符串列表进行拼接即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">arrangeWords</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        String[] words = text.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        words[<span class="number">0</span>] = words[<span class="number">0</span>].toLowerCase();</span><br><span class="line">        Arrays.sort(words, (word1, word2) -&gt; word1.length() - word2.length());</span><br><span class="line">        words[<span class="number">0</span>] = words[<span class="number">0</span>].substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + words[<span class="number">0</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：取决于内部函数；空间复杂度：取决于内部函数。</p>
</blockquote>
<h4 id="1545-找出第-N-个二进制字符串中的第-K-位"><a href="#1545-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="1545. 找出第 N 个二进制字符串中的第 K 位"></a>1545. 找出第 N 个二进制字符串中的第 K 位</h4><blockquote>
<p>※ 详见<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/zhao-chu-di-n-ge-er-jin-zhi-zi-fu-chuan-zhong-de-2/">解析</a>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = m * <span class="number">2</span> - k;</span><br><span class="line">            <span class="keyword">return</span> invert(findKthBit(n - <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (<span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;1&#x27;</span> - bit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1647-字符频次唯一的最小删除次数"><a href="#1647-字符频次唯一的最小删除次数" class="headerlink" title="1647. 字符频次唯一的最小删除次数"></a>1647. 字符频次唯一的最小删除次数</h4><blockquote>
<p>※ 记录每个字符出现的次数并按从小到大的顺序排序，然后从倒数第二个元素开始遍历，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDeletions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] charCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            charCnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(charCnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (charCnt[i] &gt; <span class="number">0</span> &amp;&amp; charCnt[i] &gt;= charCnt[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                charCnt[i]--;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="1657-确定两个字符串是否接近"><a href="#1657-确定两个字符串是否接近" class="headerlink" title="1657. 确定两个字符串是否接近"></a>1657. 确定两个字符串是否接近</h4><blockquote>
<p>※ 该题目共有四种情况：字符串长度不同，返回<code>false</code>；字符串含有的字符种类不同，返回<code>false</code>；排序后，含有的个数不同，返回<code>false</code>，其它均返回<code>true</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">closeStrings</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.length() != word2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] char1Cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] char2Cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word1.toCharArray()) &#123;</span><br><span class="line">            char1Cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word2.toCharArray()) &#123;</span><br><span class="line">            char2Cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char1Cnt[i] != <span class="number">0</span> &amp;&amp; char2Cnt[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (char1Cnt[i] == <span class="number">0</span> &amp;&amp; char2Cnt[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(char1Cnt);</span><br><span class="line">        Arrays.sort(char2Cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (char1Cnt[i] != char2Cnt[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/27/Leetcode-03-%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/27/Leetcode-03-%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">03 数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-27 18:39:26" itemprop="dateCreated datePublished" datetime="2020-09-27T18:39:26+08:00">2020-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-03 22:07:00" itemprop="dateModified" datetime="2020-11-03T22:07:00+08:00">2020-11-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><hr>
<h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h4><blockquote>
<p>※ 该题目有很多种解法，比较常见的一种便是利用移位。然而，对于二进制表示中<code>0</code>较多的情况，会进行很多不必要的移位操作。为此，可以利用<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/">布赖恩·克尼根</a>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：对于该题目，在<code>Python</code>中，可以直接利用内置函数<code>bin(x ^ y).count(&#39;1&#39;)</code>；在<code>Java</code>中，可以直接利用内置函数<code>Integer.bitCount(x ^ y)</code>进行解决。</p>
</blockquote>
<h4 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h4><blockquote>
<p>※ 判断某个整数是否为<code>2</code>的幂，只需判断该整数的二进制表示中是否只有一个<code>1</code>，即<code>n &amp; (n - 1)</code>是否为<code>0</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> x = (<span class="keyword">long</span>) n;</span><br><span class="line">        <span class="keyword">return</span> (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：刚开始做的时候没有考虑到<code>n = Integer.MIN_VALUE</code>的情况，对于该情况，<code>n &amp; (n - 1)</code>等于<code>0</code>但是并不满足<code>2</code>的幂。为此，可以将<code>n</code>转换为长整型。</p>
</blockquote>
<h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a>326. 3的幂</h4><blockquote>
<p>※ 在整型范围内，<code>3</code>的整数幂最大为<code>1162261467</code>，即<code>3</code>的<code>19</code>次幂。由于<code>3</code>为质数，因此$3^{19}$的除数只有$3^{0}$、$3^{1}$、…、$3^{19}$，因此，只需判断$3^{19}$除以<code>n</code>余数是否为<code>0</code>即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：对于求解<code>n</code>的幂，应该怎么办呢？这里给出两种方法：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/">基准转换法</a>，首先将<code>num</code>转换为<code>n</code>进制，然后利用正则表达式判断转换后的数字是否以<code>1(^1)</code>开头，后面跟着<code>0</code>或多个<code>0(0*)</code>。该种方法的时间复杂度为$O(log_{n}num)$，空间复杂度为$O(log_{n}num)$。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/">运算法</a>，若<code>num</code>为<code>n</code>的幂，则$i=log_{n}num=log_a(num)/log_a{n}$为整数，因此，只需判断<code>i%1</code>是否为整数即可。该种方法的时间复杂度为<code>Unknown</code>（取决于<code>Math.log()</code>的耗时），空间复杂度为$O(1)$。需要注意的是，<code>Math.log()</code>返回的是<code>double</code>类型的数值，可能会存在一定的误差，我们还需要将该误差考虑在内。</p>
</blockquote>
<h4 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a>342. 4的幂</h4><blockquote>
<p>※ 该题目与<code>231. 2的幂</code>类似，均利用了布赖恩·克尼根方法，只是多了一步与操作，用于判断数字为<code>2</code>的偶数次幂还是奇数次幂。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; (num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; ((num &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a>371. 两整数之和</h4><blockquote>
<p>※ 利用异或<code>^</code>运算（<code>0001^0010=0011</code>），可以得到两个整数相加后的无进位结果；利用与<code>&amp;</code>运算（<code>(0001 &amp; 0010) &lt;&lt; 1 = 0000</code>），可以得到两个整数相加时的进位信息。利用上述性质即可在不使用<code>+</code>的前提下计算出两整数之和。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">            <span class="keyword">int</span> car = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = sum;</span><br><span class="line">            b = car;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：可能是$O(N)$吧；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="441-排列硬币"><a href="#441-排列硬币" class="headerlink" title="441. 排列硬币"></a>441. 排列硬币</h4><blockquote>
<p>※ 该题目利用一元二次方程的求根公式即可轻松解决，不过需要注意的是<code>Math.sqrt()</code>函数的参数范围。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 n = 1804289383 时 Math.sqrt(2 * n) 将会溢出，具体为什么俺也不清楚。。。</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.sqrt(<span class="number">2</span>) * Math.sqrt(n + <span class="number">0.125</span>) - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h4><blockquote>
<p>※ 该题目与<code>191. 位1的个数</code>类似，均利用了布赖恩·克尼根方法，只是多了一步与操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = x ^ y;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a>476. 数字的补数</h4><blockquote>
<p>※ 对于正整数<code>1</code>，其去掉前缀<code>0</code>之后的二进制表示形式为<code>1</code>，对应的补数为<code>0</code>；对于正整数<code>5</code>，其去掉前缀<code>0</code>之后的二进制表示形式为<code>101</code>，对应的补数为<code>010</code>；可以发现，<code>0 + 1 = 1</code>、<code>101 + 010 = 111</code>。因此，可以事先计算出输入正整数去掉前缀<code>0</code>之后的二进制表示形式的位数<code>count</code>，再令<code>count</code>个<code>1</code>减去正整数即可得到它的补数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, base = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (base &lt; num) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            base = (base &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (count - <span class="number">1</span>)) - <span class="number">1</span> + (<span class="number">1</span> &lt;&lt; (count - <span class="number">1</span>)) - num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(logN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：在解决该题目时，应时刻防止数字溢出！</p>
</blockquote>
<h4 id="504-七进制数"><a href="#504-七进制数" class="headerlink" title="504. 七进制数"></a>504. 七进制数</h4><blockquote>
<p>※ 该题目比较简单，不过需要注意的是当<code>n = 0</code>的特殊情况！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> sign = num &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        num *= sign;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(String.valueOf(num % <span class="number">7</span>));</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == -<span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(logN)$；空间复杂度：$O(1)$吧。</p>
</blockquote>
<h4 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a>728. 自除数</h4><blockquote>
<p>※ 首先想到的方法便是暴力求解，但是感觉暴力求解太<code>LOW</code>了。本以为题解会有更加牛逼的方法，没想到用的居然也是暴力法。。。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = left; num &lt;= right; num++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = num;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n % <span class="number">10</span> == <span class="number">0</span> || num % (n % <span class="number">10</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a>860. 柠檬水找零</h4><blockquote>
<p>※ 每当收到一张<code>5</code>元钞票时，将<code>5</code>元钞票的数量加一；收到一张<code>10</code>元钞票时，将<code>10</code>元钞票的数量加一，<code>5</code>元钞票的数量减一；收到一张<code>20</code>元钞票时，优先使用一张<code>5</code>元钞票和一张<code>10</code>元钞票找零，若没有足够的<code>10</code>元钞票，再考虑使用三张<code>5</code>元钞票。在上述过程中，若出现了剩余钞票数量不足的情况，则说明无法找零。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums_of_five = <span class="number">0</span>, nums_of_ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                nums_of_five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums_of_five == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums_of_five--;</span><br><span class="line">                    nums_of_ten++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums_of_five &gt; <span class="number">0</span> &amp;&amp; nums_of_ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    nums_of_five--;</span><br><span class="line">                    nums_of_ten--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums_of_five &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    nums_of_five -= <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="883-三维形体投影面积"><a href="#883-三维形体投影面积" class="headerlink" title="883. 三维形体投影面积"></a>883. 三维形体投影面积</h4><blockquote>
<p>※ 对于三维形体的俯视图投影面积，等于“高度”不为<code>0</code>的元素的个数；对于三维形体的主视图投影面积，等于每一行元素的最大值之和；对于三维形体的侧视图投影面积，等于每一列元素的最大值之和。为了获取每一行和每一列元素的最大值，最先想到的是遍历二维数组两次的方式，后来在题解中发现了一种更为巧妙的方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">projectionArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每一行每一列的最大值相加，再加上不为 0 的元素的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> row_max = <span class="number">0</span>, col_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                row_max = Math.max(row_max, grid[i][j]); <span class="comment">// 妙</span></span><br><span class="line">                col_max = Math.max(col_max, grid[j][i]); <span class="comment">// 啊</span></span><br><span class="line">            &#125;</span><br><span class="line">            res += (row_max + col_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1512-好数对的数目"><a href="#1512-好数对的数目" class="headerlink" title="1512. 好数对的数目"></a>1512. 好数对的数目</h4><blockquote>
<p>※ 遍历所有可能的<code>(i, j)</code>二元组，并判断它们对应的数值是否满足<code>nums[i] == nums[j]</code>即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N)$。</p>
</blockquote>
<hr>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h4><blockquote>
<p>※ 设<code>n</code>阶格雷编码集合为<code>G(n)</code>，则<code>G(n+1)</code>阶格雷编码为：给<code>G(n)</code>阶格雷编码中的每个元素的二进制表示前添加前缀<code>0</code>；倒序为<code>G(n)</code>阶格雷编码中的每个元素的二进制表示前添加前缀<code>1</code>。根据上述规律，即可从<code>0</code>阶格雷编码推导至任意阶格雷编码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                res.add(head + res.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="319-灯泡开关"><a href="#319-灯泡开关" class="headerlink" title="319. 灯泡开关"></a>319. 灯泡开关</h4><blockquote>
<p>※ 对于第<code>i</code>个灯泡，只有当<code>i</code>为完全平方数时，经过<code>N</code>轮之后其才会变为开启状态；这是因为完全平方数的因子数有奇数个，而灯泡经过奇数次操作之后会变为相反的状态。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h4><blockquote>
<p>※ 对于<code>1</code>来说，其二进制表示中<code>1</code>的数目等于<code>0</code>的二进制表示中<code>1</code>的数目加<code>1</code>；对于<code>2</code>和<code>3</code>来说，它们的二进制表示中<code>1</code>的数目等于<code>0</code>和<code>1</code>的二进制表示中<code>1</code>的数目加<code>1</code>；对于<code>4</code>、<code>5</code>、<code>6</code>和<code>7</code>来说，它们的二进制表示中<code>1</code>的数目等于<code>0</code>、<code>1</code>、<code>2</code>和<code>3</code>的二进制表示中<code>1</code>的数目加<code>1</code>。找到该规律后，便可以利用动态规划进行解决。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            res[i] = res[i - d] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) / <span class="number">2</span> == d) &#123;</span><br><span class="line">                d *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h4><blockquote>
<p>※ 比较简单的排列组合类型问题，只是存在一些边界情况需要考虑，如<code>n = 0</code>或<code>n &gt; 10</code>，前者有<code>10</code>种可能结果，后者始终有<code>8877691</code>种可能结果（因为只有<code>10</code>个阿拉伯数字，第<code>10+</code>位无论是哪个数字定会重复）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (n == 0) &#123;</span></span><br><span class="line">        <span class="comment">//     return 1;</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     int res = 10;</span></span><br><span class="line">        <span class="comment">//     int a = 9, b = 9;</span></span><br><span class="line">        <span class="comment">//     int count = n &gt; 10 ? 10 : n; // 很重要！！！</span></span><br><span class="line">        <span class="comment">//     for (int i = 1; i &lt; count; i++) &#123;</span></span><br><span class="line">        <span class="comment">//         res += (a * b);</span></span><br><span class="line">        <span class="comment">//         a *= b--;</span></span><br><span class="line">        <span class="comment">//         // b--;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return res;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8877691</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">9</span>, b = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                res += (a * b);</span><br><span class="line">                a *= b--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(1)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="396-旋转函数"><a href="#396-旋转函数" class="headerlink" title="396. 旋转函数"></a>396. 旋转函数</h4><blockquote>
<p>※ <code>F(k + 1)</code>与<code>F(k)</code>之间存在如下关系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0 * A[0] + 1 * A[1] + 2 * A[2] + ... + (n - 1) * A[n - 1]</span><br><span class="line">F(1) = 0 * A[n - 1] + 1 * A[0] + 2 * A[1] + ... + (n - 1) * A[n - 2]</span><br><span class="line">F(2) = 0 * A[n - 2] + 1 * A[n - 1] + 2 * A[0] + ... + (n - 1) * A[n - 3]</span><br><span class="line">F(n - 1) = 0 * A[1] + 1 * A[2] + 2 * A[3] + ... + (n - 1) * A[0]</span><br><span class="line"></span><br><span class="line">F(1) - F(0) = A[0] + A[1] + ... + A[n - 1] - n * A[n - 1]</span><br><span class="line">F(2) - F(1) = A[0] + A[1] + ... + A[n - 1] - n * A[n - 2]</span><br><span class="line">F(n - 1) - F(n - 2) = A[0] + A[1] + ... + A[n - 1] - n * A[1]</span><br><span class="line"></span><br><span class="line">F(1) = F(0) + SUM - n * A[n -1]</span><br><span class="line">F(2) = F(1) + SUM - n * A[n -2]</span><br><span class="line">F(n - 1) = F(n - 2) - n * A[1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> SUM = <span class="number">0</span>, F_0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            SUM += A[i];</span><br><span class="line">            F_0 += i * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = F_0, n = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> F_1 = SUM + F_0 - n * A[n - i];</span><br><span class="line">            max = Math.max(max, F_1);</span><br><span class="line">            F_0 = F_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807. 保持城市天际线"></a>807. 保持城市天际线</h4><blockquote>
<p>※ 该题目与<code>883. 三维形体投影面积</code>类似，均利用了投影的性质。首先，对二维数组进行遍历，求出每一行、每一列的最大值；然后，再次对二维数组进行遍历，对于每一个元素<code>grid[i][j]</code>，其可以增加的最大高度等于<code>Math.min(row_max[i], col_max[j]) - grid[i][j]</code>；最后，将所有元素可以增加的最大高度累加在一起，得到最终结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] row_max = <span class="keyword">new</span> <span class="keyword">int</span>[row];</span><br><span class="line">        <span class="keyword">int</span>[] col_max = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                row_max[i] = Math.max(row_max[i], grid[i][j]);</span><br><span class="line">                col_max[j] = Math.max(col_max[j], grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                res += Math.min(row_max[i], col_max[j]) - grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1637-两点之间不包含任何点的最宽垂直面积"><a href="#1637-两点之间不包含任何点的最宽垂直面积" class="headerlink" title="1637. 两点之间不包含任何点的最宽垂直面积"></a>1637. 两点之间不包含任何点的最宽垂直面积</h4><blockquote>
<p>※ 该题目比较简单，对<code>points</code>进行排序，比较两个相邻<code>point</code>的<code>x</code>坐标之间的差值，并保留最大差值即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWidthOfVerticalArea</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (P1, P2) -&gt; P1[<span class="number">0</span>] - P2[<span class="number">0</span>]); <span class="comment">// 如何对二维数组进行排序？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i + <span class="number">1</span>][<span class="number">0</span>] - points[i][<span class="number">0</span>] &gt; res) &#123;</span><br><span class="line">                res = points[i + <span class="number">1</span>][<span class="number">0</span>] - points[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxWidthOfVerticalArea</span>(<span class="params">self, points: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        points.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> points[i + <span class="number">1</span>][<span class="number">0</span>] - points[i][<span class="number">0</span>] &gt; res:</span><br><span class="line">                res = points[i + <span class="number">1</span>][<span class="number">0</span>] - points[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：取决于内部函数；空间复杂度：取决于内部函数。</p>
</blockquote>
<h4 id="1642-可以到达的最远建筑"><a href="#1642-可以到达的最远建筑" class="headerlink" title="1642. 可以到达的最远建筑"></a>1642. 可以到达的最远建筑</h4><blockquote>
<p>※ 优先利用梯子去爬高度相差较大的楼层，当梯子不够时，再利用砖块去爬。基于上述思想，可以利用优先队列。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">furthestBuilding</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> bricks, <span class="keyword">int</span> ladders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,  n = heights.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = heights[i + <span class="number">1</span>] - heights[i];</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(diff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; ladders) &#123;</span><br><span class="line">                bricks -= queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bricks &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：取决于内部函数；空间复杂度：取决于内部函数。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/Leetcode-05-%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/Leetcode-05-%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">05 优先搜索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-24 14:53:11" itemprop="dateCreated datePublished" datetime="2020-09-24T14:53:11+08:00">2020-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-14 09:48:25" itemprop="dateModified" datetime="2020-10-14T09:48:25+08:00">2020-10-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h4><blockquote>
<p>※ 该题目可以抽象成图的深度优先搜索，比较简单。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != board.length - <span class="number">1</span> &amp;&amp; j != <span class="number">0</span> &amp;&amp; j != board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; visited[i][j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    DFS(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; visited[i][j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> dx = x + direction[<span class="number">0</span>], dy = y + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= dx &amp;&amp; dx &lt; board.length &amp;&amp; <span class="number">0</span> &lt;= dy &amp;&amp; dy &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[dx][dy] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; visited[dx][dy] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    visited[dx][dy] = <span class="keyword">true</span>;</span><br><span class="line">                    DFS(board, dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：在解决该题目时借助了一个与<code>board</code>同样大小的<code>boolean</code>数组，若题目规定不能声明新的数组，此时你知道该怎么办嘛？</p>
</blockquote>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h4><blockquote>
<p>※ 该题目可以抽象成图的深度优先搜索，比较简单。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; visited[i][j] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    DFS(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> dx = x + direction[<span class="number">0</span>], dy = y + direction[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= dx &amp;&amp; dx &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= dy &amp;&amp; dy &lt; grid[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[dx][dy] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; visited[dx][dy] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    visited[dx][dy] = <span class="keyword">true</span>; <span class="comment">// 利用 visited 防止重复访问</span></span><br><span class="line">                    DFS(grid, dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：该题目同样可以利用广度优先搜索和并查集解决，并且这两种方法的复杂度在某种程度上均优于深度优先搜索，后面有时间可以试一下。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/Leetcode-02-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/Leetcode-02-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">02 数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-24 11:48:46" itemprop="dateCreated datePublished" datetime="2020-09-24T11:48:46+08:00">2020-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 09:54:52" itemprop="dateModified" datetime="2020-11-23T09:54:52+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><hr>
<h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h4><blockquote>
<p>※ 对数组进行排序，下标为<code>n/2</code>的元素一定为众数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h4><blockquote>
<p>※ 对数组中的元素进行遍历，并将遍历过的元素保存至<code>HashSet</code>中。对于某个新访问的元素，判断其是否存在于<code>HashSet</code>中，若存在，则说明数组中存在重复元素；若不存在，则将其保存至<code>HashSet</code>中，并继续进行遍历，直至遍历完所有元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p>※ 对数组进行排序，若数组中存在重复元素，则重复元素一定相邻。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：取决于排序算法，若为堆排序，则为$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：由<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode/">题解</a>得知，对于一些特定的<code>n</code>不太大的测试样例，方法一的运行速度可能会比方法二慢，这是因为哈希表在维护其属性时，需要一些额外的开销。</p>
<p><strong>注</strong>：方法二对原数组进行了修改，通常情况下，除非调用方清楚输入数据会被修改，否则不应该随意修改输入数据。为此，可以先复制<code>nums</code>，然后对副本进行操作。</p>
</blockquote>
<h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h4><blockquote>
<p>※ 对数组中的元素进行遍历，并将遍历过的元素及其下标保存至<code>HashMap</code>中。对于某个新访问的元素，判断其是否存在于<code>HashSet</code>中，并且满足下标之差的绝对值至多为<code>k</code>，若存在，则说明数组中存在满足约束的重复元素；若不存在，则将其及其下标保存至<code>HashMap</code>中，并继续进行遍历，直至遍历完所有元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(nums[i]) != <span class="keyword">null</span> &amp;&amp; i - map.get(nums[i]) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p>※ 考虑到只需要在满足下标约束（即下标之差的绝对值至多为<code>k</code>）的元素中进行查找，因此可以维护一个大小为<code>k</code>的<code>HashSet</code>，并始终在该<code>Set</code>中进行查找。由此，空间复杂度将降为$O(min(N, K))$。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(min(N,K))$。</p>
</blockquote>
<h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h4><blockquote>
<p>※ 借助快慢指针的思想，将快指针指向当前元素，慢指针指向可移动位置，快指针与慢指针之间的所有元素均为零。若当前元素不为零，则交换快慢指针所指元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[j];</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h4><blockquote>
<p>※ 首先，遍历长度较小的数组，并将数组中每个数字以及它们出现的次数存储在<code>Map</code>中；然后，遍历另一个数组，对于另一个数组中的每个数字，若<code>Map</code>中存在该数字，则将该数字添加到答案，并减少<code>Map</code>中该数字出现的次数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(nums2[i], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[index++] = nums2[i];</span><br><span class="line">                map.put(nums2[i], count - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, index); <span class="comment">// 如何复制数组？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M + N)$；空间复杂度：$O(min(M, N))$。</p>
</blockquote>
<h4 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a>374. 猜数字大小</h4><blockquote>
<p>※ 首先能想到的方法便是依次遍历所有数字，但是这种方法的时间复杂度较高。若借助二分查找的思想，能够将时间复杂度优化至$O(logn)$。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>, max = n;</span><br><span class="line">        <span class="keyword">int</span> mid = min + (max - min) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (guess(mid) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess(mid) == <span class="number">1</span>) &#123;</span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = min + (max - min) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(logN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a>485. 最大连续1的个数</h4><blockquote>
<p>※ 遍历数组，用<code>count</code>记录当前连续<code>1</code>的个数，<code>maxCount</code>记录当前最大连续<code>1</code>的个数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxCount = Math.max(count, maxCount);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(count, maxCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h4><blockquote>
<p>※ 最先想到的方法是：首先，借助<code>Map</code>保存<code>nums1</code>中的元素以及每个元素对应的下一个更大元素（初始时均为<code>-1</code>）；然后，遍历<code>nums2</code>，判断当前数字是否包含在<code>Map</code>中，若存在，则借助内部循环找到当前元素的下一个更大元素，若不存在，则遍历下一数字；最后，将<code>Map</code>的值返回即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            map.put(nums1[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums2[i])) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums2[j] &gt; nums2[i]) &#123;</span><br><span class="line">                        map.put(nums2[i], nums2[j]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M + N)$，其中<code>M</code>、<code>N</code>分别表示<code>nums1</code>、<code>nums2</code>的长度；空间复杂度：$O(M)$。</p>
</blockquote>
<blockquote>
<p>※ 除此之外，题解中还给出了一种利用单调栈解决的方法，避免了内部循环所带来的重复遍历，按理说这种方法的时间复杂度应该要优于上一种方法，但事实证明，这种方法的运行时间更长。个人猜测可能与测试用例的设计有关。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek()) &#123;</span><br><span class="line">                map.put(stack.pop(), nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            map.put(stack.pop(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>※ 时间复杂度：$O(M + N)$，其中<code>M</code>、<code>N</code>分别表示<code>nums1</code>、<code>nums2</code>的长度；空间复杂度：$O(N)$。</p>
<h4 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a>500. 键盘行</h4><blockquote>
<p>※ 将键盘上每一行的字母以集合的形式单独保存起来，然后将单词转换为集合，并判断其是否为某一行的子集。<span style="color:green">好久没用Python，都快忘了怎么用了。QAQ</span></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span>(<span class="params">self, words: List[str]</span>) -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        lines = [set(<span class="string">&#x27;QWERTYUIOP&#x27;</span>), set(<span class="string">&#x27;ASDFGHJKL&#x27;</span>), set(<span class="string">&#x27;ZXCVBNM&#x27;</span>)]</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_set = set(word.upper())</span><br><span class="line">            <span class="keyword">if</span> word_set.issubset(lines[<span class="number">0</span>]) <span class="keyword">or</span> word_set.issubset(lines[<span class="number">1</span>]) <span class="keyword">or</span> word_set.issubset(lines[<span class="number">2</span>]):</span><br><span class="line">                res.append(word)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：应该是$O(N)$吧，其中<code>N</code>表示所有单词包含的字符个数；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a>506. 相对名次</h4><blockquote>
<p>※ 首先，对<code>nums</code>进行复制，得到<code>nums_clone</code>；然后，对<code>nums_clone</code>进行排序，并利用<code>Map</code>保存每个元素的排名；最后，基于每个元素的排名给出它的名次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findRelativeRanks(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums_clone = nums.clone();</span><br><span class="line">        Arrays.sort(nums_clone);</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums_clone[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res[i] = toString(nums.length - map.get(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> rank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rank == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(rank);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h4><blockquote>
<p>※ 比较经典的题目，一般情况下都能够将时间复杂度和空间复杂度分别优化至$O(n)$和$O(1)$。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span> || N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pre1 = <span class="number">0</span>, pre2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">                pre1 = pre2;</span><br><span class="line">                pre2 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pre2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：利用矩阵求幂的方法，可以将时间复杂度优化至$O(logN)$；利用公式法，可以将时间复杂度和空间复杂度均优化至$O(1)$，后面有时间可以试一下。</p>
</blockquote>
<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h4><blockquote>
<p>※ 对于二叉搜索树，其中序遍历是递增的；反过来，若先访问右子树，再访问根节点，最后访问左子树，则遍历是递减的（这正是我们所需要的）。基于此，只需反向中序遍历二叉搜索树，记录遍历过程中的节点值之和，并不断更新当前遍历节点的节点值，即可得到累加树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：该题目同样可以利用<code>Morris</code>方法解决，后面有时间可以试一下。</p>
</blockquote>
<h4 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a>561. 数组拆分 I</h4><blockquote>
<p>※ 对数组进行排序，计算偶数下标对应的数字之和即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a>682. 棒球比赛</h4><blockquote>
<p>※ 遍历字符串数组，若当前字符串为整数，则保存至栈中；否则，依据当前字符串对应的规则对栈进行操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String op : ops) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> newtop = stack.peek() + top;</span><br><span class="line">                stack.push(top);</span><br><span class="line">                stack.push(newtop);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;D&quot;</span>)) &#123;</span><br><span class="line">                stack.push(<span class="number">2</span> * stack.peek());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;C&quot;</span>)) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.valueOf(op));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h4><blockquote>
<p>※ 简单的二分查找，难点在于各种变形，如存在重复元素，数组进行了旋转，找到某个元素最先或最后出现的位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(logN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a>832. 翻转图像</h4><blockquote>
<p>※ 没有什么骚操作，按照题意一步一步来即可。需要注意的是，对于宽度为奇数的情况，不要忘记对其中间位置的数字进行反转。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> rows = A.length, cols = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="comment">// for (int j = 0; j &lt; cols / 2; j++) &#123;</span></span><br><span class="line">            <span class="comment">//     int num = 1 - A[i][j];</span></span><br><span class="line">            <span class="comment">//     A[i][j] = 1 - A[i][cols - j - 1];</span></span><br><span class="line">            <span class="comment">//     A[i][cols - j - 1] = num;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (cols % 2 == 1) &#123;</span></span><br><span class="line">            <span class="comment">//     A[i][cols / 2] = 1 - A[i][cols / 2];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (cols + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">1</span> - A[i][j];</span><br><span class="line">                A[i][j] = <span class="number">1</span> - A[i][cols - j - <span class="number">1</span>];</span><br><span class="line">                A[i][cols - j - <span class="number">1</span>] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h4><blockquote>
<p>※ 定义两个指针<code>i</code>、<code>j</code>，初始时分别指向数组的第<code>0</code>、<code>A.length - 1</code>个元素；比较两个指针所指元素的平方，选择较大的那个逆序放入结果数组中，并移动指针；重复上述过程，直至<code>i &gt; j</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>, pos = A.length - <span class="number">1</span>; i &lt;= j; pos--) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = A[i] * A[i], right = A[j] * A[j];</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                res[pos] = left;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[pos] = right;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a>1002. 查找常用字符</h4><blockquote>
<p>※ 依次遍历每个字符串，对字符串中每个字符出现的次数进行统计，最后，取每个字符出现次数的最小值即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] min_count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(min_count, Integer.MAX_VALUE); <span class="comment">// Get 新技能</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[i].length(); j++) &#123;</span><br><span class="line">                count[A[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                min_count[j] = Math.min(min_count[j], count[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; min_count[i]; j++) &#123;</span><br><span class="line">                res.add(String.valueOf((<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NM)$，其中，<code>N</code>表示字符串的个数，<code>M</code>表示字符串的平均长度；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1184-公交站间的距离"><a href="#1184-公交站间的距离" class="headerlink" title="1184. 公交站间的距离"></a>1184. 公交站间的距离</h4><blockquote>
<p>※ 按照题目意思，分别从前往后、从后往前对数组进行遍历并累加，取两次累加的最小值作为最终结果即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distanceBetweenBusStops</span><span class="params">(<span class="keyword">int</span>[] distance, <span class="keyword">int</span> start, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> forward = <span class="number">0</span>, backward = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i != destination; i = (i + <span class="number">1</span>) % distance.length) &#123;</span><br><span class="line">            forward += distance[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = destination; i != start; i = (i + <span class="number">1</span>) % distance.length) &#123;</span><br><span class="line">            backward += distance[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(forward, backward);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431. 拥有最多糖果的孩子"></a>1431. 拥有最多糖果的孩子</h4><blockquote>
<p>※ 对于每一个孩子，只要其拥有的糖果数量加上额外的糖果数量大于所有孩子拥有的糖果数量的最大值，即可用于最多糖果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, candies[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; i++) &#123;</span><br><span class="line">            <span class="comment">// if (candies[i] + extraCandies &gt;= max) &#123;</span></span><br><span class="line">            <span class="comment">//     res.add(true);</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     res.add(false);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            res.add(candies[i] + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1470-重新排列数组"><a href="#1470-重新排列数组" class="headerlink" title="1470. 重新排列数组"></a>1470. 重新排列数组</h4><blockquote>
<p>※ 该题目比较简单，按照题意一个一个遍历即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[<span class="number">2</span> * i] = nums[i];</span><br><span class="line">            res[<span class="number">2</span> * i + <span class="number">1</span>] = nums[i + n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：该题目的空间复杂度最优可以降至<code>O(1)</code>，后面有时间可以试一下。</p>
</blockquote>
<h4 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a>1480. 一维数组的动态和</h4><blockquote>
<p>※ 该题目比较简单，利用一个临时变量，便可实现<code>O(1)</code>空间复杂度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            nums[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a>1486. 数组异或操作</h4><blockquote>
<p>※ 按照题意，依次对数字进行异或操作即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<hr>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h4><blockquote>
<p>※ 将每行和每列的第一个元素视为标记，用于表示该行或该列是否需要置零。对于第一行元素，可以额外声明一个变量，用于表示第一行是否需要置零。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断第一行是否需要置零</span></span><br><span class="line">        <span class="keyword">boolean</span> setZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                setZero = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断第一列是否需要置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (setZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// MD，我是真的菜，看完解析做了三遍才做出来。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：该题目尤其需要注意置零时的顺序，即首先对第一行之外的行进行置零，然后对所有列进行置零，最后对第一行进行置零！</p>
</blockquote>
<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h4><blockquote>
<p>※ 利用指针<code>P_0</code>来交换<code>0</code>，<code>p_2</code>来交换<code>2</code>。从左向右遍历数组，设当前遍历到的位置为<code>i</code>，对应的元素为<code>nums[i]</code>。若<code>nums[i] = 0</code>，则将其与<code>nums[p_0]</code>进行交换，并将<code>p_0</code>向后移动一个位置；若<code>nums[i] = 2</code>，则将其与<code>nums[p_2]</code>进行交换，并将<code>p_2</code>向前移动一个位置。需要注意的是，当我们找到<code>2</code>时，需要不断将其与<code>nums[p_2]</code>进行交换，直至新的<code>nums[i]</code>不为<code>2</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p_0 = <span class="number">0</span>, p_2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p_2; i++) &#123; <span class="comment">// 这里应取到等于。</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p_2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                nums[i] = nums[p_2];</span><br><span class="line">                nums[p_2--] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = nums[p_0];</span><br><span class="line">                nums[p_0++] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h4><blockquote>
<p>※ 首先能够想到的便是利用二分搜索，问题在于如何更新状态。对于<code>left</code>、<code>mid</code>、<code>right</code>，它们之间的关系存在如下四种可能：<code>&lt; &lt;</code>、<code>&lt; &gt;</code>、<code>&gt; &lt;</code>、<code>&gt; &gt;</code>，分析出每种可能对应的状态更新，便能够轻松解决该题目。更详细的分析请参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">题解</a>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 能否取等号取决于 mid 能否等于 right</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(logN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a>220. 存在重复元素 III</h4><blockquote>
<p>※ 基于桶排序的思想，将窗口当作桶来实现一个线性复杂度的解法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Long, Long&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Long&gt;(); <span class="comment">// 注意需要用到 Long 类型，防止溢出。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = getBucketId(nums[i], t + <span class="number">1</span>); <span class="comment">// t + 1 !!!</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.containsKey(id - <span class="number">1</span>) &amp;&amp; Math.abs(map.get(id - <span class="number">1</span>) - nums[i]) &lt;= t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.containsKey(id + <span class="number">1</span>) &amp;&amp; Math.abs(map.get(id + <span class="number">1</span>) - nums[i]) &lt;= t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(id, (<span class="keyword">long</span>) nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; k) &#123;</span><br><span class="line">                map.remove(getBucketId(nums[i - k], t + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getBucketId</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span> ? num / t : (num + <span class="number">1</span>) / t - <span class="number">1</span>; <span class="comment">// 注意判断条件为 num &gt;= 0 而非 num &gt; 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$，对于任意一个元素，最多只需要进行三次搜索，一次插入和一次删除，这些操作均为常量时间复杂度的；空间复杂度：$O(min(N,K))$，需要开辟的额外空间取决于<code>HashMap</code>的大小，而<code>HashMap</code>的大小的上限同时由<code>N</code>和<code>K</code>决定。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：该题目同样可以利用二叉搜索树解决，后面有时间可以试一下。</p>
</blockquote>
<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h4><blockquote>
<p>※ 初始化两个空数组<code>L</code>、<code>R</code>，对于<code>L</code>，其第<code>i</code>个元素表示<code>nums</code>中第<code>i</code>个元素之前所有数的乘积；对于<code>R</code>，其第<code>i</code>个元素表示<code>nums</code>中第<code>i</code>个元素之后所有数的乘积。借助上述思想，便可解决该题目。然而，上述思想的空间复杂度只有<code>O(N)</code>，达不到进阶的要求。为此，考虑将返回的结果数组视为<code>L</code>，通过一个常数维护<code>R</code>，从而达到<code>O(1)</code>空间复杂度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            res[i] = res[i] * temp;</span><br><span class="line">            temp *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h4><blockquote>
<p>※ 首先，利用优先队列保存前<code>K</code>个元素；然后，依次遍历剩余元素，若当前遍历元素大于优先队列队头的元素，则将队头元素弹出并放入当前元素；最后，返回队头元素即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; num) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$。</p>
<p><strong>TODO</strong>：有时间可以了解一下堆排序、快速排序和归并排序。</p>
</blockquote>
<h4 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a>289. 生命游戏</h4><blockquote>
<p>※ 该题目与<code>130. 被围绕的区域</code>类似，同样可以借助其它数字来表示“细胞”状态的更新，如<code>-1</code>表示细胞由活变死，<code>2</code>表示细胞由死变活。这里需要注意的是第<code>11</code>行代码，此时，<code>board[x][y] = -1</code>同样表示活细胞。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length, cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + direction[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + direction[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> &lt; x &amp;&amp; x &lt; rows &amp;&amp; -<span class="number">1</span> &lt; y &amp;&amp; y &lt; cols &amp;&amp; (board[x][y] == <span class="number">1</span> || board[x][y] == -<span class="number">1</span>)) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; count == <span class="number">3</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="number">1</span> &amp;&amp; (count &lt; <span class="number">2</span> || count &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    board[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h4><blockquote>
<p>※ 将所有人按照<code>h</code>从大到小，<code>k</code>从小到大的顺序进行排序，并对排序后的数组进行遍历。当遍历到第<code>i</code>个人时，前<code>i - 1</code>个人已经被安排好了位置，他们只要站在第<code>i</code>个人的前面，就会对其产生影响，因为他们都不比第<code>i</code>个人低；后<code>n - i</code>个人无论站在哪里，只有在身高与第<code>i</code>个人一致时才会对其产生影响，基于此，可以采用“插空”的方法，依次给每个人在当前的队列中选择一个插入的位置，即对于第<code>i</code>个人，需要将其插入队列中，并使得他的前面恰好有$k_i$个人即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// 按照身高（h）降序，人数（k）升序的顺序对数组进行排序</span></span><br><span class="line">        Arrays.sort(people, (person1, person2) -&gt; person1[<span class="number">0</span>] == person2[<span class="number">0</span>] ? person1[<span class="number">1</span>] - person2[<span class="number">1</span>] : person2[<span class="number">0</span>] - person1[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;(); <span class="comment">// 这是什么瞎逼操作？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            list.add(person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">int</span>[][]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="419-甲板上的战舰"><a href="#419-甲板上的战舰" class="headerlink" title="419. 甲板上的战舰"></a>419. 甲板上的战舰</h4><blockquote>
<p>※ 完全没有思路，看了<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/battleships-in-a-board/solution/">题解</a>之后才会做，我真的是好菜啊。对二维矩阵进行扫描，扫描到<code>X</code>时，如果其上方或左方也是<code>X</code>，则不计数，否则计数加<code>1</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="436-寻找右区间"><a href="#436-寻找右区间" class="headerlink" title="436. 寻找右区间"></a>436. 寻找右区间</h4><blockquote>
<p>※ 首先，依次遍历每个区间，将区间的左端点及其对应的下标保存至<code>TreeMap</code>中；然后，再次遍历每个区间，并利用<code>ceilingKey()</code>函数查询是否存在比当前区间右端点大的键值对，若不存在，则说明满足条件的区间不存在，否则，将区间对应的下标保存至<code>res</code>数组中即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRightInterval(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        <span class="comment">// Map&lt;Integer, Integer&gt; map = new TreeMap&lt;Integer, Integer&gt;(); // 这样写是不对的，无法调用 Treeset 的 ceilingKey 函数！</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(intervals[i][<span class="number">0</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Integer key = map.ceilingKey(intervals[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res[map.get(intervals[i][<span class="number">0</span>])] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[map.get(intervals[i][<span class="number">0</span>])] = map.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$，<code>TreeMap</code>的插入操作需要$O(logN)$的时间，<code>ceilingKey</code>也需要$O(logN)$的时间；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h4><blockquote>
<p>※ 该题目具有一定的技巧性，有两种常见解法：一种为原地修改元素为负数作为访问标记，另一种为原地加<code>n</code>作为访问标记。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// // 方法一：原地修改元素为负数作为访问标记</span></span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     int index = Math.abs(nums[i]); // 防止 nums[i] &lt; 0</span></span><br><span class="line">        <span class="comment">//     if (nums[index - 1] &lt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//         res.add(index);</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         nums[index - 1] = - nums[index - 1];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="comment">// 方法二：原地加 n 投机取巧</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[(nums[i] - <span class="number">1</span>) % n] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span> * n) &#123;</span><br><span class="line">                res.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h4><blockquote>
<p>※ 对<code>points</code>数组进行排序，然后定义<code>lower</code>、<code>upper</code>两个变量以保存相交区间，依次判断每个<code>point</code>与<code>lower</code>、<code>upper</code>是否存在交集，若不存在，则说明需要一支弓箭。<strong>注</strong>：调用<code>Arrays.sort()</code>函数对数组进行排序时要用逻辑运算符而不是算术运算符进行判断，因为可能会溢出；此外，每遍历完一个点，切记利用<code>upper = Math.min(upper, point[1])</code>对<code>upper</code>进行更新。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt; () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (point1[<span class="number">0</span>] &lt; point2[<span class="number">0</span>]) &#123; <span class="comment">// 这里直接用 - 号进行判断可能会溢出。。。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">0</span>] &gt; point2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">1</span>] &lt; point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">1</span>] &gt; point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lower = points[<span class="number">0</span>][<span class="number">0</span>], upper = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (point[<span class="number">0</span>] &lt;= upper) &#123;</span><br><span class="line">                lower = point[<span class="number">0</span>];</span><br><span class="line">                upper = Math.min(upper, point[<span class="number">1</span>]); <span class="comment">// [[1, 10], [3, 9]] !!! </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">                lower = point[<span class="number">0</span>];</span><br><span class="line">                upper = point[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611. 有效三角形的个数"></a>611. 有效三角形的个数</h4><blockquote>
<p>※ 对数组进行排序并利用双指针即可解决该题目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res += (k - j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$，代码跟官方题解几乎一样，个人感觉时间复杂度还是$O(N^3)$，不清楚为什么官方题解给了$O(N^2)$；空间复杂度：$O(logN)$，排序所需空间。</p>
</blockquote>
<h4 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a>670. 最大交换</h4><blockquote>
<p>※ 自右向左统计大于（不包含等于）当前字符的最大字符的下标；然后，自左向右遍历字符，若当前字符的下标不等于大于其最大字符的下标，并且这两个字符不相等（该约束很重要！），则对它们进行交换并退出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] nums = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="keyword">char</span> max_c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> max_i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        arr[max_i] = max_i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max_c) &#123;</span><br><span class="line">                max_c = nums[i];</span><br><span class="line">                max_i = i;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = max_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != i &amp;&amp; nums[arr[i]] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = nums[arr[i]];</span><br><span class="line">                nums[arr[i]] = nums[i];</span><br><span class="line">                nums[i] = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a>692. 前K个高频单词</h4><blockquote>
<p>※ 计算每个单词的频率，并将他们存储至大小为<code>k</code>的小根堆中，最后，从堆中最多弹出<code>k</code>次，并反转结果，即可得到前<code>k</code>个高频单词。<strong>注</strong>：需要留意在初始化堆时如何指定<code>Comparator</code>！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            count.put(word, count.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;String&gt;((word1, word2) -&gt; count.get(word1) == count.get(word2) ? word2.compareTo(word1) : count.get(word1) - count.get(word2));</span><br><span class="line">        <span class="keyword">for</span> (String word : count.keySet()) &#123;</span><br><span class="line">            queue.offer(word);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogK)$，将<code>N</code>个单词添加到堆中，每次向堆中添加每个单词的时间复杂度为$O(logk)$；空间复杂度：$O(N)$，用于存储计数空间。</p>
</blockquote>
<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h4><blockquote>
<p>※ 该题目与<code>496. 下一个更大元素 I</code>类似，同样利用了“单调栈”的思想，只是这里将元素的下标保存至栈中，而非元素本身。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = stack.pop();</span><br><span class="line">                res[pos] = i - pos;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a>845. 数组中的最长山脉</h4><blockquote>
<p>※ 定义指针<code>l</code>指向左侧山脚，初始值为<code>0</code>。当每次固定完<code>l</code>后，首先，需要保证<code>l + 2 &lt; n</code>，因为山脉的长度至少为<code>3</code>；其次，需要保证<code>A[l] &lt; A[l + 1]</code>，否则<code>l</code>对应的不可能为左侧山脚；然后，将指向右侧山脚的指针<code>r</code>初始值置为<code>l + 1</code>，并不断向右移动<code>r</code>，直至<code>A[r] &lt; A[r + 1]</code>不满足，此时：若<code>r = n - 1</code>，说明已经移至了数组末尾，无法形成山脉；否则，<code>r</code>对应的可能为山顶，还需要额外判定是否有<code>A[r] &gt; A[i + 1]</code>，若是则说明<code>r</code>对应的为山顶，此时应采用类似的方法，不断向右移动<code>r</code>，直至<code>A[r] &gt; A[r + 1]</code>不满足，<code>r - l + 1</code>即对应着山脉的长度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, n = A.length;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[l] &lt; A[r]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; A[r] &lt; A[r + <span class="number">1</span>]) &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n &amp;&amp; A[r] &gt; A[r + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; A[r] &gt; A[r + <span class="number">1</span>]) &#123;</span><br><span class="line">                        r++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = Math.max(res, r - l + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a>973. 最接近原点的 K 个点</h4><blockquote>
<p>※ 将每个点到原点的欧几里得距离的平方从小到大排序，取前<code>K</code>个即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> point1[<span class="number">0</span>] * point1[<span class="number">0</span>] + point1[<span class="number">1</span>] * point1[<span class="number">1</span>] - point2[<span class="number">0</span>] * point2[<span class="number">0</span>] - point2[<span class="number">1</span>] * point2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(points, <span class="number">0</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a>1004. 最大连续1的个数 III</h4><blockquote>
<p>※ 该题目可以理解为：滑动窗口内最多有<code>K</code>个<code>0</code>，求滑动窗口的最大长度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 滑动窗口表示的区间为[left, right)，左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.length) &#123;</span><br><span class="line">            <span class="comment">// 窗口扩充一个元素，若为 0 则 count++；</span></span><br><span class="line">            <span class="keyword">if</span> (A[right++] == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当窗口内 0 的个数超过 K 时，开始收缩窗口。</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; K) &#123;</span><br><span class="line">                <span class="comment">// 若滑出窗口的元素是 0，则 count--；</span></span><br><span class="line">                <span class="keyword">if</span> (A[left++] == <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 count &lt;= K，保存窗口的最大宽度；</span></span><br><span class="line">            maxCount = Math.max(maxCount, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a>1282. 用户分组</h4><blockquote>
<p>※ 首先，用<code>HashMap</code>对所有用户进行“粗分组”，其中，<code>Key</code>对应了<code>groupSize</code>，表示用户组的大小；<code>value</code>对应了<code>userList</code>，表示用户组中的所有用户；接着，对每个键值对中的<code>value</code>进行细分组，即每经过<code>key</code>个用户，便新建一个链表，用于保存下一个用户分组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; groupThePeople(<span class="keyword">int</span>[] groupSizes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = groupSizes.length;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = map.getOrDefault(groupSizes[i], <span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(groupSizes[i], list);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index : entry.getValue()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                list.add(index);</span><br><span class="line">                <span class="keyword">if</span> (count % entry.getKey() == <span class="number">0</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1395-统计作战单位数"><a href="#1395-统计作战单位数" class="headerlink" title="1395. 统计作战单位数"></a>1395. 统计作战单位数</h4><blockquote>
<p>※ 该题目最先能想到的便是利用暴力法，但是暴力法的时间复杂度较高，有没有更好的方法呢？有的，枚举中间点就可以使得时间复杂度降至$O(N^2)$。具体来说，枚举三元组<code>(i, j, k)</code>中的<code>j</code>，并统计：出现在<code>j</code>左侧并且比<code>j</code>评分低的士兵数量<code>l_s</code>；出现在<code>j</code>左侧并且比<code>j</code>屏风高的士兵数量<code>l_l</code>；出现在<code>j</code>右侧并且比<code>j</code>评分低的士兵数量<code>r_s</code>；出现在<code>j</code>右侧并且比<code>j</code>评分高的士兵数量<code>r_l</code>。这样一来，以<code>j</code>为中间点的满足条件的三元组数量为：<code>l_s * r_l + l_l * r_s</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="keyword">int</span>[] rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = rating.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l_s = <span class="number">0</span>, l_l = <span class="number">0</span>, r_s = <span class="number">0</span>, r_l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rating[j] &lt; rating[i]) &#123;</span><br><span class="line">                    l_s++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rating[j] &gt; rating[i]) &#123;</span><br><span class="line">                    l_l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rating[j] &lt; rating[i]) &#123;</span><br><span class="line">                    r_s++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rating[j] &gt; rating[i]) &#123;</span><br><span class="line">                    r_l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (l_s * r_l + l_l * r_s); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1503-所有蚂蚁掉下来前的最后一刻"><a href="#1503-所有蚂蚁掉下来前的最后一刻" class="headerlink" title="1503. 所有蚂蚁掉下来前的最后一刻"></a>1503. 所有蚂蚁掉下来前的最后一刻</h4><blockquote>
<p>※ 该题的关键点在于：两只相遇的蚂蚁同时改变方向后，其情形等价于两只蚂蚁均未改变方向。这样，问题便可以简化成根据每只蚂蚁的初始位置和移动方向得到最后一只蚂蚁到达模板边界的时刻。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : left) &#123;</span><br><span class="line">            res = Math.max(res, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : right) &#123;</span><br><span class="line">            res = Math.max(res, n - num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="1630-等差子数组"><a href="#1630-等差子数组" class="headerlink" title="1630. 等差子数组"></a>1630. 等差子数组</h4><blockquote>
<p>※ 依次拷贝每一个子数组，并对子数组进行排序，然后依次判断子数组中的每个元素是否满足等差数列的性质<code>2 * A[i] == A[i + 1] + A[i - 1]</code>即可。<strong>注</strong>：当子数组的长度小于<code>3</code>时必为等差数组。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">checkArithmeticSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] l, <span class="keyword">int</span>[] r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = l.length;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> LinkedList&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] subArray = Arrays.copyOfRange(nums, l[i], r[i] + <span class="number">1</span>);</span><br><span class="line">            Arrays.sort(subArray);</span><br><span class="line">            <span class="keyword">if</span> (subArray.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> sign = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;subArray.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">2</span> * subArray[j] != subArray[j - <span class="number">1</span>] + subArray[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        sign = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(sign);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：待定；空间复杂度：待定。</p>
</blockquote>
<h4 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a>1631. 最小体力消耗路径</h4><blockquote>
<p>※ 假设当前最短路径的长度为<code>limit</code>，对二维数组进行广度优先搜索，并且只扩展“长度”小于等于<code>limit</code>的边，若能够扩展到目的节点，则缩小<code>limit</code>，否则扩大<code>limit</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="keyword">int</span>[][] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = heights.length, cols = heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            Deque&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">            <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">            visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] pos = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> x = pos[<span class="number">0</span>], y = pos[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + direction[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + direction[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> &lt; nx &amp;&amp; nx &lt; rows &amp;&amp; -<span class="number">1</span> &lt; ny &amp;&amp; ny &lt; cols &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(heights[nx][ny] - heights[x][y]) &lt;= m) &#123;</span><br><span class="line">                            visited[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (visited[rows - <span class="number">1</span>][cols - <span class="number">1</span>]) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[rows - <span class="number">1</span>][cols - <span class="number">1</span>]) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：待定；空间复杂度：待定。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/Leetcode-01-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/Leetcode-01-%E6%A0%91/" class="post-title-link" itemprop="url">01 树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-24 11:46:30" itemprop="dateCreated datePublished" datetime="2020-09-24T11:46:30+08:00">2020-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-24 09:57:33" itemprop="dateModified" datetime="2020-11-24T09:57:33+08:00">2020-11-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><hr>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h4><blockquote>
<p>※ 选择数组中间位置的数字作为二叉搜索树的根节点，则分给左右子树的数字个数相等或只相差<code>1</code>，由此可以使得二叉搜索树保持平衡。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">            node.left = buildBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">            node.right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(logN)$。</p>
</blockquote>
<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h4><blockquote>
<p>※ 自底向上遍历该平衡二叉树，若某颗子树不是平衡二叉树，那么该二叉树便不是平衡二叉树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = height(node.left);</span><br><span class="line">        <span class="keyword">int</span> r = height(node.right);</span><br><span class="line">        <span class="keyword">if</span> (l == -<span class="number">1</span> || r == -<span class="number">1</span> || Math.abs(l - r) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(l, r) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h4><blockquote>
<p>※ <code>p</code>、<code>root</code>、<code>q</code>之间共有可能存在<code>9</code>种大小关系，弄清每种大小关系出现时，如何进行下一步判断，就能够轻松解决该题目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h4><blockquote>
<p>※ 想了一段时间后实在想不出来，就按照官方题解实现了一下。狗屎，时间复杂度和空间复杂度完全比不上利用递归的时间复杂度和空间复杂度。好在借此机会了解了一下真·$O(1)$空间复杂度的<code>Morris</code>遍历方法，如果有题目规定不能使用额外的空间，包括由递归产生的隐式调用栈的开销，那么该方法就派的上用场了。另外，在此分享一篇关于介绍<code>Morris</code>遍历方法的不错的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">博客</a>，后面有时间可以仔细看一看。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> base, count, maxCount;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若当前节点的左孩子为空，则输出当前节点，并将当前节点更新为它的右孩子。</span></span><br><span class="line">                counter(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode preNode = node.left;</span><br><span class="line">                <span class="comment">// 若当前节点的左孩子不为空，则在其左子树中找到其前驱节点。</span></span><br><span class="line">                <span class="keyword">while</span> (preNode.right != <span class="keyword">null</span> &amp;&amp; preNode.right != node) &#123;</span><br><span class="line">                    preNode = preNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (preNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若前驱节点的右孩子为空，则将其右孩子设置为当前节点，</span></span><br><span class="line">                    <span class="comment">// 并将当前节点更新为当前节点的左孩子。</span></span><br><span class="line">                    preNode.right = node;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若前驱节点的右孩子为当前节点，则将其右孩子重新设为空（恢复树的形状），</span></span><br><span class="line">                    <span class="comment">// 输出当前节点，并将当前节点更新为当前节点的右孩子。</span></span><br><span class="line">                    preNode.right = <span class="keyword">null</span>;</span><br><span class="line">                    counter(node.val);</span><br><span class="line">                    node = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] mode = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class="line">            mode[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val == base) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            base = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            res.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            res.clear();</span><br><span class="line">            res.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：该题目还可以利用递归解决，并且运行效果更好，后面有时间可以试一下。</p>
</blockquote>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h4><blockquote>
<p>※ 二叉搜索树有一个很重要的性质：其中序遍历得到的序列是非单调递减的。基于该性质，该题目一种常见的解法是：首先，对二叉搜索树进行中序遍历，并将节点值保存至数组中；然后，对数组进行遍历，保存相邻元素之差的绝对值；最后，从所有相邻元素之差的绝对值中取最小值。然而，为了保存节点值，我们需要使用额外的空间，能否在遍历过程中直接获取相邻元素呢？答案是肯定的（见代码）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pre = -<span class="number">1</span>, res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        middleOrderTraversal(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">middleOrderTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        middleOrderTraversal(node.left);</span><br><span class="line">        <span class="comment">// 这两个条件语句避免了额外引入数组保存节点值！</span></span><br><span class="line">        <span class="keyword">if</span> (pre == -<span class="number">1</span>) &#123;</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.min(res, Math.abs(node.val - pre));</span><br><span class="line">            pre = node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        middleOrderTraversal(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h4><blockquote>
<p>※ 两个二叉树中对应的节点存在以下几种情况：一个节点为空，另一个节点不为空，此时合并后的节点应该为不为空的那个节点；两个节点均不为空，此时合并后的节点为其中任意一个节点即可，但需要对返回的节点的值进行修改；两个节点均为空，此时合并后的节点为其中任意一个节点即可，反正都为空。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    <span class="keyword">private</span> TreeNode node = root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 != <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.val = t1.val + t2.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.val = t2.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.val = t1.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M,N)$，其中<code>M</code>、<code>N</code>分别表示两个二叉树的节点数，只有当两个二叉树中对应的节点均不为空时，才会对两个节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数；空间复杂度：$O(M,N)$，空间复杂度取决于递归调用的层数，而递归调用的层数不会超过较小的二叉树的节点数。</p>
</blockquote>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h4><blockquote>
<p>※ 该题目比较简单，依据二叉搜索树的性质，递归进行求解即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<hr>
<h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a>103. 二叉树的锯齿形层次遍历</h4><blockquote>
<p>※ 借助双端队列和一个用于指定方向的临时变量即可解决。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_to_right = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        deque.offerFirst(root);</span><br><span class="line">        <span class="keyword">while</span>(deque.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = deque.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left_to_right == <span class="number">0</span>) &#123;</span><br><span class="line">                    TreeNode node = deque.pollLast();</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deque.offerFirst(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deque.offerFirst(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode node = deque.pollFirst();</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deque.offerLast(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deque.offerLast(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left_to_right = <span class="number">1</span> - left_to_right;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h4><blockquote>
<p>※ 对于前序遍历来说，最先遍历的节点一定为根节点；借助中序遍历，可以分别得知根节点左右子树包含节点的数量，从而进一步获取它们的先序遍历和中序遍历。以此类推，利用递归便可解决该题目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len - <span class="number">1</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[index] == val) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, index + <span class="number">1</span>), Arrays.copyOfRange(inorder, <span class="number">0</span>, index));</span><br><span class="line">        node.right = buildTree(Arrays.copyOfRange(preorder, index + <span class="number">1</span>, len), Arrays.copyOfRange(inorder, index + <span class="number">1</span>, len));</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：在获取<code>index</code>以及对数组进行复制<code>Arrays.copyOfRange()</code>时，涉及到了大量的遍历，这些遍历其实是可以通过增加形参省略的，你知道怎么做嘛？</p>
</blockquote>
<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h4><blockquote>
<p>※ 对于后序遍历来说，最后遍历的节点一定为根节点；借助中序遍历，可以分别得知根节点左右子树包含节点的数量，从而进一步获取它们的中序遍历和后序遍历。以此类推，利用递归便可解决该题目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = postorder.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = postorder[len - <span class="number">1</span>];</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len - <span class="number">1</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[index] == val) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = buildTree(Arrays.copyOfRange(inorder, <span class="number">0</span>, index), Arrays.copyOfRange(postorder, <span class="number">0</span>, index));</span><br><span class="line">        node.right = buildTree(Arrays.copyOfRange(inorder, index + <span class="number">1</span>, len), Arrays.copyOfRange(postorder, index, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：同样的，在获取<code>index</code>以及对数组进行复制<code>Arrays.copyOfRange()</code>时，涉及到了大量的遍历，这些遍历其实是可以通过增加形参省略的，你知道怎么做嘛？</p>
</blockquote>
<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a>109. 有序链表转换二叉搜索树</h4><blockquote>
<p>※ 该题目与<code>108. 将有序数组转换为二叉搜索树</code>类似，只是将有序数组换为了有序链表。在解决该题目时，首先可以利用快慢指针找到链表的中间节点，并以该中间节点作为当前二叉搜索树的根节点，然后分别以中间节点两侧的链表递归构建二叉搜索树，作为该根节点的左子树和右子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBST</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对应链表只包含一个节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(node.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对应链表包含两个或两个以上节点的情况</span></span><br><span class="line">            ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">            ListNode slow = node, fast = node;</span><br><span class="line">            <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = slow;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">            pre.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 若链表中只包含两个节点，则 pre 指向 node，即第一个节点；</span></span><br><span class="line">            <span class="comment">// slow 指向第二个节点，fast 指向 null。</span></span><br><span class="line">            <span class="comment">// 此时，以 slow 作为根节点，node 作为左孩子节点，null作为右孩子节点是合理的。</span></span><br><span class="line">            root.left = buildBST(node);</span><br><span class="line">            root.right = buildBST(slow.next);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NlogN)$；空间复杂度：$O(logN)$，递归过程中栈的最大深度，也即平衡二叉树的高度。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>： <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-1-3/">题解</a>中还给出了一种分治加中序遍历优化的方法，在空间复杂度保持<code>O(logN)</code>的前提下，时间复杂度只有<code>O(N)</code>。此外，该题目与上一题均是将中间节点作为了根节点，那么按照该种方法构造出的二叉树一定是平衡的吗？答案是肯定的，但是你知道要怎么证明吗？这些题解里都有，后面有时间可以看一下。</p>
</blockquote>
<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h4><blockquote>
<p>※ 该题目与<code>117. 填充每个节点的下一个右侧节点指针 II</code>的区别在于，指定了二叉树为完美二叉树。由完美二叉树的性质可以得知：只要每一层第一个节点的左孩子不为空，那么下一层的节点就一定都存在。利用该性质，便可解决该题目。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span> (start.left != <span class="keyword">null</span>) &#123; <span class="comment">// 只要 start.left 不为零，就能保证下一层节点都存在</span></span><br><span class="line">            Node nextStart = start.left;</span><br><span class="line">            <span class="keyword">for</span> (Node node = start; node != <span class="keyword">null</span>; node = node.next) &#123;</span><br><span class="line">                node.left.next = node.right;</span><br><span class="line">                <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.right.next = node.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h4><blockquote>
<p>※ 在访问第<code>i</code>层时，建立第<code>i+1</code>层节点的<code>next</code>指针，便能够将时间复杂度由层次遍历的<code>O(n)</code>降至<code>O(1)</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node nextStart = <span class="keyword">null</span>, nextEnd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span> (start != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            nextEnd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node node = start; node != <span class="keyword">null</span>; node = node.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helper(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helper(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextStart == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextStart = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextEnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextEnd.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        nextEnd = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h4><blockquote>
<p>※ 对二叉树进行从右往左的层次遍历，遍历每一层节点之前，先保留当前层最右边的节点的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            res.add(queue.peek().val);</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h4><blockquote>
<p>※ 该题目的关键在于计算二叉树的深度以及最底层叶子节点的个数。对于前者，可以对二叉树进行深度优先搜索，并保存每个节点对应的深度，<strong>最先</strong>遇到的满足<code>root.left == null &amp;&amp; root.right == null</code>的节点对应的深度即为该二叉树的深度；对于后者，可以借助上一步中求出的<code>depth</code>，在对二叉树进行深度优先搜索的同时获取。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> setDepth = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>, depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        DFS(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">2</span>, <span class="keyword">this</span>.depth) + <span class="keyword">this</span>.count - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.depth == <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.setDepth) &#123;</span><br><span class="line">                <span class="keyword">this</span>.setDepth = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.depth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.depth == depth) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DFS(root.left, depth + <span class="number">1</span>);</span><br><span class="line">            DFS(root.right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h4><blockquote>
<p>※ 二叉搜索树中第<code>K</code>小的元素对应了二叉搜索树中序遍历的第<code>K</code>个元素，因此，只需对二叉搜索树进行中序遍历，并对遍历过的节点进行计数，待遍历到第<code>K</code>个节点时，返回该节点的值即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inOrderTraversal(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraversal(root.left, k);</span><br><span class="line">        key++;</span><br><span class="line">        <span class="comment">// if (key == k) &#123;</span></span><br><span class="line">        <span class="comment">//     res = root.val;</span></span><br><span class="line">        <span class="comment">//     return;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (key == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraversal(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<blockquote>
<p><strong>TODO</strong>：第<code>34</code>行引入的条件语句能够缩短递归执行时间吗？</p>
</blockquote>
<h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h4><blockquote>
<p>※ 该题目和二叉树的层次遍历类似，均采用了相同的框架，只是在向队列中添加节点时有所不同（这里直接调用了<code>addAll()</code>函数，关于该函数，后面有时间可以仔细看一下）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">// Way 1:</span></span><br><span class="line">                <span class="comment">// List&lt;Node&gt; children = node.children;</span></span><br><span class="line">                <span class="comment">// for (int i = 0; i &lt; children.size(); i++) &#123;</span></span><br><span class="line">                <span class="comment">//     queue.offer(children.get(i));</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// Way 2:</span></span><br><span class="line">                <span class="comment">// for (Node child : node.children) &#123;</span></span><br><span class="line">                <span class="comment">//     queue.offer(child);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// Way 3:</span></span><br><span class="line">                queue.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a>513. 找树左下角的值</h4><blockquote>
<p>※ 最先想到的方法是：从上往下，从左往右依次遍历二叉树每一层的节点，在遍历每一层节点之前，先用一个临时变量保存当前层的第一个节点的值，直至遍历到最后一层。然而，这样的方法需要额外定义两个临时变量，并且程序结构较为复杂，是否存在更为简单明了的方法？答案是肯定的（见代码）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            root = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h4><blockquote>
<p>※ 该题目比较简单，利用递归即可进行求解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = getMaxIndex(nums, l, r);</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[index]);</span><br><span class="line">        node.left = buildTree(nums, l, index - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, index + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_value = Integer.MIN_VALUE, max_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_value &lt; nums[i]) &#123;</span><br><span class="line">                max_value = nums[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h4><blockquote>
<p>※ 遍历当前节点，假设当前节点的值小于待插入的值，若当前节点的右孩子不为空，则继续遍历当前节点的右孩子；若当前节点的右孩子为空，则直接为当前节点新建一个右孩子，并将右孩子的值赋值为待插入的值。反之亦然。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insertIntoBST(root.right, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insertIntoBST(root.left, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1302-层数最深叶子节点的和"><a href="#1302-层数最深叶子节点的和" class="headerlink" title="1302. 层数最深叶子节点的和"></a>1302. 层数最深叶子节点的和</h4><blockquote>
<p>※ 对二叉树进行层次遍历，每遍历一层便将该层所有节点的和保存至<code>res</code>中，待程序运行结束时，<code>res</code>中保存的便为二叉树最深叶子节点的和。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                res += node.val;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<hr>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><hr>
<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a>968. 监控二叉树</h4><blockquote>
<p>※ 对于某个节点来说，可能存在以下<code>3</code>种状态：<code>0</code>，当前节点需要被监控；<code>1</code>：当前节点已经被监控；<code>2</code>：当前节点需要放置摄像头。弄清楚这<code>3</code>种状态便能够轻松解决该题目。需要注意的是，不要忘记对根节点的状态进行判断，若根节点处于状态<code>0</code>，则需要将摄像头的个数加一。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DFS(root) == <span class="number">0</span>) &#123; <span class="comment">// 不要忘记根节点！！！</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0: 需要被监控；</span></span><br><span class="line">    <span class="comment">// 1: 已经被监控；</span></span><br><span class="line">    <span class="comment">// 2: 需要放置摄像头；</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若 node 为空，则 node 已经被监控；</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> left = DFS(node.left), right = DFS(node.right);</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">1</span> &amp;&amp; right == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 若 left 和 right 均为 1，则 node 需要被监控；</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若 left 或 right 为 0，则 node 需要放置摄像头；</span></span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其余情况包含 12 21 22，此时 node 已经被监控；</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘晨</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
