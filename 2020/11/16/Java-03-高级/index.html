<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Day 001   ※ 在计算机中，我们把一个任务称为一个进程；某些进程内部还需要同时执行多个子任务，我们把这些子任务称为线程。进程与线程之间的关系为：一个进程可以包含多个线程，但至少会有一个线程。注：操作系统调度的最小任务单位不是进程，而是线程！ ※ 同一个应用程序中，既可以有多个进程，又可以有多个线程，因此，实现多任务的方法有以下几种：多进程模式（每个进程只有一个线程）；多线程模式（一个进程有">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级">
<meta property="og:url" content="http://example.com/2020/11/16/Java-03-%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="阿晨的博客">
<meta property="og:description" content="Day 001   ※ 在计算机中，我们把一个任务称为一个进程；某些进程内部还需要同时执行多个子任务，我们把这些子任务称为线程。进程与线程之间的关系为：一个进程可以包含多个线程，但至少会有一个线程。注：操作系统调度的最小任务单位不是进程，而是线程！ ※ 同一个应用程序中，既可以有多个进程，又可以有多个线程，因此，实现多任务的方法有以下几种：多进程模式（每个进程只有一个线程）；多线程模式（一个进程有">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-16T14:58:04.000Z">
<meta property="article:modified_time" content="2020-12-26T07:59:48.143Z">
<meta property="article:author" content="刘晨">
<meta property="article:tag" content="高级">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/11/16/Java-03-%E9%AB%98%E7%BA%A7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java高级 | 阿晨的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">阿晨的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">年度最佳摸鱼选手</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Day-001"><span class="nav-number">1.</span> <span class="nav-text">Day 001</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Day-002"><span class="nav-number">2.</span> <span class="nav-text">Day 002</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Day-003"><span class="nav-number">3.</span> <span class="nav-text">Day 003</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Day-004"><span class="nav-number">4.</span> <span class="nav-text">Day 004</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘晨"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">刘晨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/Java-03-%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java高级
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-16 22:58:04" itemprop="dateCreated datePublished" datetime="2020-11-16T22:58:04+08:00">2020-11-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-26 15:59:48" itemprop="dateModified" datetime="2020-12-26T15:59:48+08:00">2020-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h4 id="Day-001"><a href="#Day-001" class="headerlink" title="Day 001"></a>Day 001</h4><blockquote>
<!-- Part 001 -->

<p>※ 在计算机中，我们把一个任务称为一个<span style="color:red">进程</span>；某些进程内部还需要同时执行多个子任务，我们把这些子任务称为<span style="color:red">线程</span>。进程与线程之间的关系为：一个进程可以包含多个线程，但至少会有一个线程。<strong>注</strong>：操作系统调度的最小任务单位不是进程，而是线程！</p>
<p>※ 同一个应用程序中，既可以有多个进程，又可以有多个线程，因此，实现多任务的方法有以下几种：<span style="color:blue">多进程模式</span>（每个进程只有一个线程）；<span style="color:blue">多线程模式</span>（一个进程有多个线程）；<span style="color:blue">多进程加多线程模式</span>（每个进程有多个线程）。</p>
<p>※ 与多线程相比，多进程的缺点在于：创建进程比创建线程开销大，尤其是在<code>Windows</code>系统上；进程间通信比线程间通信慢，因为线程间通信是读写同一个变量，速度很快。与多进程相比，多线程的缺点在于：稳定性较差，因为在多进程的情况下，一个进程崩溃不会影响其它进程，而在多线程的情况下，任何一个线程崩溃都将导致整个进程崩溃。</p>
<p>※ <code>Java</code>语言内置了多线程支持：一个<code>Java</code>程序实际上是一个<code>JVM</code>进程，<code>JVM</code>进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，还可以启动多个线程。此外，<code>JVM</code>还有负责垃圾回收的其它工作线程等。<strong>注</strong>：多线程模型是<code>Java</code>程序最基本的并发模型，后继读写网络、数据库、<code>Web</code>开发等都依赖于<code>Java</code>多线程模型。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<!-- Part 002 -->

<p>※ 创建新线程有以下三种方式：</p>
<p>👉 继承<code>Thread</code>类，并重写<code>run()</code>方法；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>👉 创建实现<code>Runnable</code>接口的类，并在创建<code>Thread</code>实例时传入；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>👉 借助匿名类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 调用<code>run()</code>方法是无法启动新线程的，只是相当于调用了一个普通的<code>Java</code>方法。若想启动新线程，必须调用<code>start()</code>方法。<strong>注</strong>：在<code>Thread</code>类的源码中可以看到，<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示该方法是由<code>JVM</code>虚拟机内部的<code>C</code>代码实现的，而非<code>Java</code>代码。</p>
<p>※ 可以对线程设定优先级，设定优先级的方法为：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：操作系统对优先级高的线程调度更为频繁，但并不能保证优先级高的线程一定会先执行。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>Java</code>线程的状态有以下几种：<span style="color:blue"><code>New</code></span>，新创建的线程，尚未运行；<span style="color:blue"><code>Runnable</code></span>，运行中的线程，正在执行<code>run()</code>方法；<span style="color:blue"><code>Blocked</code></span>：运行中的线程，因为某些操作被阻塞而挂起；<span style="color:blue"><code>Waiting</code></span>：运行中的线程，因为某些操作在等待中；<span style="color:blue"><code>Timed Waiting</code></span>：运行中的线程，因为执行<code>sleep()</code>方法在计时等待；<span style="color:blue"><code>Terminated</code></span>：线程已终止。</p>
<p>※ 线程终止的原因有以下三种：正常终止，即<code>run</code>方法执行到<code>return</code>语句返回；意外终止，即<code>run()</code>方法因未捕获的异常导致线程终止；对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</p>
<p>※ 通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束，也可以指定等待时间，待超过等待时间后便不再等待。此外，对已经运行结束的线程调用<code>join()</code>方法会立即返回。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 线程在执行一个长时间的任务时，可能需要被中断。<span style="color:blue">中断线程</span>就是其它线程给目标线程发送一个请求，目标线程在收到请求后，结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。中断线程非常简单，只需要在其它线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身是否是<code>interrupted</code>状态，若是则立刻结束运行。<strong>注</strong>：目标线程能否正确响应其它线程发来的中断请求，需要看具体代码。</p>
<p>※ 若对处于等待状态的线程调用<code>interrupt()</code>方法，线程的<code>join()</code>方法将会抛出<code>InterruptedException</code>异常。换句话说，若线程捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>异常，就说明有其它线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应立刻结束运行。</p>
<p>※ 另一个常用的中断线程的方法为设置标志位，即用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把该标志位设置为<code>false</code>，便可以让线程结束。<strong>注</strong>：标志位应为线程间共享变量，用关键字<code>volatile</code>标记，从而确保每个线程都能读取到更新后的变量值。</p>
<p>※ 为什么要对线程间共享的变量用<code>volatile</code>声明？这涉及到<code>Java</code>的内存模型。在<code>Java</code>虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，会先获取一个副本，并保存在自己的工作内存中。若线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时刻是不确定的。这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。因此，<code>volatile</code>关键字的目的是告诉虚拟机：每次访问变量时，总是获取内存的最新值；每次修改变量后，立刻回写到主内存。<!-- 存疑 --></p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <span style="color:blue">守护线程</span>是指为其它线程服务的线程。在<code>JVM</code>中，待所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。<strong>注</strong>：虚拟机退出后，非守护线程自然也就结束了，换句话说，非守护线程不用刻意去关闭。</p>
<p>※ 守护线程不能持有任何需要关闭的资源，如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<p>※ 创建守护线程，只需要在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>方法将该线程标记为守护线程。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。这时，若多个线程同时读写共享变量，便会出现数据不一致的问题。对共享变量进行读取和写入时，必须保证是<span style="color:blue">原子操作</span>，即不能被中断的一个或一系列操作。</p>
<p>※ <code>Java</code>程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：在使用<code>synchronized</code>的时候，不用担心抛出异常，因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁。</p>
<p>※ 虽然<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题，但是带来了性能下降，这不但是因为代码块无法并发执行，还因为加锁和解锁需要消耗一定的时间。</p>
<p>※ <code>JVM</code>规范定义了几种原子操作：基本类型赋值（<code>long</code>、<code>double</code>除外）；引用类型赋值。对于单条原子操作来说并不需要同步！<strong>注</strong>：<code>long</code>、<code>double</code>是64位数据，<code>JVM</code>没有明确规定64位赋值操作是不是同一个原子操作，但是在<code>X64</code>平台的<code>JVM</code>是把<code>long</code>和<code>double</code>赋值作为原子操作实现的。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 让线程自己选择锁对象往往会使代码逻辑混乱，并且不利于封装，更好的方法是把<code>synchronized</code>逻辑封起来，即：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样一来，线程调用<code>add()</code>方法时，将不必关心同步逻辑，因为<code>synchronized</code>代码块在该方法内部。此外，<code>synchronized</code>锁住的对象为<code>this</code>，即当前实例，这使得创建多个<code>Counter</code>实例时，它们之间互不影响。</p>
<p>※ 若一个类被设计为允许多线程正确访问，则称该类为<span style="color:blue">线程安全</span>的。<code>Java</code>标准库中的<code>StringBuilder</code>是线程安全的；一些不变类，如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程访问时只能读不能写，也是线程安全的；此外，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>※ 当锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法，即：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法也被称为同步方法，表示整个方法都必须用<code>this</code>实例加锁。</p>
<p>※ 对于<code>static</code>实例，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是注意到任何一个类都有一个由<code>JVM</code>自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。<!-- 存疑 --></p>
</blockquote>
<blockquote>
<!-- Part 008 -->

<p>※ <code>JVM</code>允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，称为<span style="color:blue">可重入锁</span>。</p>
<p>※ 当多线程各自持有不同的锁，并互相试图获取对方已持有的锁时，将导致无限等待，此时便陷入了<span style="color:blue">死锁</span>。</p>
<p>※ 在编写多线程应用时，要特别注意防止死锁，因为死锁一旦形成，就只能强制结束<code>JVM</code>进程。避免死锁的方法为多线程获取锁的顺序要一致！</p>
</blockquote>
<blockquote>
<!-- Part 009 -->

<p>※ 多线程协调运行的原则为：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<p>※ <code>wait</code>和<code>notify</code>用于多线程协调运行，在<code>synchronzied</code>内部可以调用<code>wait()</code>使线程进入等待状态，但必须在已获得的锁对象上调用<code>wait()</code>方法；在<code>synchronzied</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其它等待线程，但必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法。<strong>注</strong>：已唤醒的线程需要重新获得锁后才能继续执行。<!-- 存疑（你给我解释解释，什么TM的叫TM的已获得的锁对象） --></p>
</blockquote>
<blockquote>
<!-- Part 010 -->

<p>※ <code>ReentrantLock</code>可以用于替代<code>synchronized</code>进行同步，与<code>synchronized</code>相比，<code>ReentrantLock</code>可以在指定时间范围内尝试获取锁，一旦超过指定时间范围，程序可以做一些额外处理，而不是无限等待下去，这样可以有效避免死锁：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// lock() 方法表示当前线程占用 lock 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 必须调用 unlock() 方法进行手动释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<!-- Part 011 -->

<p>※ <code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步，那么该如果实现<code>synchronized</code>下的<code>wait</code>和<code>notify</code>呢？可以使用<code>Condition</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>对象。</p>
<p>※ <code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法在原理上和<code>synchronized</code>锁对象提供的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>方法是一致的，并且行为也是一样的：<code>await()</code>用于释放当前锁并进入等待状态；<code>signal()</code>用于唤醒某个等待线程；<code>signalAll()</code>用于唤醒所有等待线程。<strong>注</strong>：与<code>trylock()</code>类似，<code>await()</code>可以在等待指定时间后自己醒来。</p>
</blockquote>
<blockquote>
 <!-- Part 012 -->

<p>※ 在读多写少的场景中，利用<code>ReadWriteLock</code>可以提高读取效率：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：在论坛中，回复可以视为写入操作，它是不频繁的，浏览可以视为读取操作，它是频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
</blockquote>
<blockquote>
<!-- Part 013 -->

<p>※ 在<code>Java 8</code>中，引入了新的读写锁<code>StampedLock</code>，与<code>ReadWriteLock</code>相比，前者的改进之处在于：读的过程中也允许获取写锁后写入。但是这样可能会导致读的数据不一致，因此需要一点儿额外的代码来判断读的过程中是否有写入：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>ReadWriteLock</code>相比，写入的加锁是完全一致的，不同的是读取。首先，通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号；接着，待读取完成后，通过<code>validate()</code>去验证版本号，若在读取过程中没有写入，版本号不变，验证成功；若在读取过程中有写入，版本号改变，验证失败，此时将再通过获取悲观读锁进行读取。可见，<code>StampedLock</code>将读锁细分为乐观读锁和悲观读锁，其中，<span style="color:blue">乐观读锁</span>是指乐观地估计读的过程中大概率不会有写入；<span style="color:blue">悲观读锁</span>是指读的过程中拒绝有写入。然而，如此细分也是有代价的：一是代码更加复杂，二是<code>StampedLock</code>为不可重入锁，不能在一个线程中反复获取同一个锁！</p>
</blockquote>
<blockquote>
<!-- Part 014 -->

<p>※ 针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Queue</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包提供了对应的并发集合类：</p>
<table>
<thead>
<tr>
<th align="center">interface</th>
<th align="center">non-thread-safe</th>
<th align="center">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>List</code></td>
<td align="center"><code>ArrayList</code></td>
<td align="center"><code>CopyOnWriteArrayList</code></td>
</tr>
<tr>
<td align="center"><code>Map</code></td>
<td align="center"><code>HashMap</code></td>
<td align="center"><code>ConcurrentHashMap</code></td>
</tr>
<tr>
<td align="center"><code>Set</code></td>
<td align="center"><code>HashSet/TreeSet</code></td>
<td align="center"><code>CopyOnWriteArraySet</code></td>
</tr>
<tr>
<td align="center"><code>Queue</code></td>
<td align="center"><code>ArrayDeque/LinkedList</code></td>
<td align="center"><code>ArrayBlockingQueue/LinkedBlockingQueue</code></td>
</tr>
<tr>
<td align="center"><code>Deque</code></td>
<td align="center"><code>ArrayDeque/LinkedList</code></td>
<td align="center"><code>LinkedBlockingDeque</code></td>
</tr>
</tbody></table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。</p>
<p>※ <code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该转换器实际上只是用一个包装类包装了非线程安全的<code>Map</code>，然后对所有读写方法都用<code>synchronized</code>加锁，这样获取的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，不推荐使用！</p>
</blockquote>
<blockquote>
<!-- Part 015 -->

<p>※ <code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，这些封装类位于<code>java.util.concurrent.atomic</code>包中。</p>
<p>※ <code>Atomic</code>类是通过<strong>无锁</strong>的方式实现的线程安全访问，它的主要原理是利用了<code>CAS(Compare and Set)</code>。其中，<code>CAS</code>是指若<code>AtomicInteger</code>的当前值为<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>；若<code>AtomicInteger</code>的当前值不为<code>prev</code>，就什么都不干，返回<code>false</code>。通过<code>CAS</code>操作并配合<code>do ... while</code>循环，即使其它线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。<strong>注</strong>：该类适用于计数器，累加器等。</p>
</blockquote>
<blockquote>
<!-- Part 016 -->

<p>※ <code>Java</code>语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁线程需要消耗大量时间。如果可以复用一组线程，那么就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程，这种能接收大量小任务并进行分发处理的就是<span style="color:blue">线程池</span>。换句话说，线程池内部维护了若干个线程，没有任务的时候，这些线程均处于等待状态，有新任务的时候，就分配一个空闲线程执行。若所有线程均处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>※ <code>Java</code>标准库提供了<code>ExecutorService</code>接口表示线程池，其典型用法如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<code>ExecutorService</code>接口，<code>Java</code>标准库提供的几个常用实现类有：<code>FixedThreadPoll</code>，线程数固定的线程池；<code>ChchedThreadPoll</code>，线程数根据任务动态调整的线程池；<code>SingleThreadExecutor</code>，仅单线程执行的线程池。</p>
<p>※ 线程池在程序结束的时候要关闭！使用<code>shutdown()</code>方法关闭线程池时，会等待正在执行的任务完成后再关闭；使用<code>shutdownNow()</code>方法关闭线程池时，会立即停止正在执行的任务；使用<code>awaitTermination()</code>方法关闭线程池时，会等待指定的时间让线程池关闭。</p>
<p>※ 还有一种任务，需要定期反复执行，如每秒刷新证券的价格。这种任务本身固定，需要反复执行，可以使用<code>ScheduledThreadPool</code>，放入其中的任务可以定期反复执行：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>FixedRate</code>和<code>FixedDelay</code>的区别：前者是指任务总是以固定时间间隔触发，不管执行时间有多长；后者是指上一次任务执行完毕后，再等待固定的时间间隔执行任务。<span style="color:red"><strong>注</strong></span>：在<code>FixedRate</code>模式下，假设任务的执行时间超过了其运行周期，则后续执行可能会延迟开始，但不会并发执行；此外，若任务的任何执行遇到了异常，将禁止后续任务的执行。</p>
<p>※ <code>Java</code>标准库提供的<code>java.util.Timer</code>类同样可以定期执行任务，但是，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPoll</code>可以调度多个定时任务，因此完全可以用<code>ScheduledThreadPoll</code>取代旧的<code>Timer</code>。</p>
</blockquote>
<blockquote>
<!-- Part 017 -->

<p>※ 使用<code>Java</code>标准库提供的线程池执行多个任务是非常方便的，我们提交的任务只需要实现<code>Runnable</code>接口即可让线程池去执行：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，<code>Runnable</code>接口没有返回值，如果任务需要一个返回结果，那么只能保存到变量，并提供额外的方法读取。为此，<code>Java</code>标准库提供了一个<code>Callable</code>接口，与<code>Runnable</code>接口相比，它多了一个返回值：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。那么问题来了，该如何获取异步执行的结果呢？如果仔细查看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型的实例，该实例代表一个未来能获取结果的对象：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们提交一个<code>Callable</code>任务后，同时会获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用该对象的<code>get()</code>方法，即可获得异步执行的结果。<strong>注</strong>：在调用<code>get()</code>时，如果异步任务已经执行完成，则可以直接获得结果；如果异步任务尚未执行完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>※ 一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：<code>get()</code>，获取结果，但可能会等待；<code>get(long timeout, TimeUnit unit)</code>，获取结果，但只等待指定的时间；<code>isDone()</code>，判断任务是否已经完成；<code>cancel(boolean mayInterruptIfRunning)</code>，取消当前任务。</p>
</blockquote>
<blockquote>
<!-- Part 018 -->

<p>※ 使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询查看<code>isDone()</code>是否为<code>true</code>，这两种方法均不是很好，因为主线程也会被迫等待。从<code>Java 8</code>引入了<code>CompletableFuture</code>，它对<code>Future</code>进行了改进，可以传入回调对象，当异步任务完成或者发生异常时，将自动调用回调对象的回调方法。</p>
<p>※ 创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象。紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象；异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象。</p>
<p>※ 与<code>Future</code>相比，<code>CompletableFuture</code>更大的优势在于：既可以串行化执行，又可以并行化执行。具体地，<code>thenApplyAsync()</code>方法用于串行化另一个<code>CompletableFuture</code>；<code>anyOf()</code>和<code>allOf()</code>方法用于并行化多个<code>CompletableFuture</code>。</p>
</blockquote>
<blockquote>
<!-- Part 019 -->

<p>※ <code>Java 7</code>开始引入了一种新的<code>Fork/Join</code>线程池，它可以执行一种特殊的任务：将一个大任务拆成多个小任务并行执行。<strong>注</strong>：任务类必须继承自<code>RecursiveTask</code>或<code>RecursiveAction</code>。</p>
</blockquote>
<blockquote>
<!-- Part 020 -->

<p>※ <code>Thread</code>对象代表一个线程，在代码中调用<code>Thread.currentThread()</code>方法可以获取当前线程。</p>
<p>※ 在一个线程中，横跨若干种方法调用，需要传递的对象，通常称之为上下文，它是一种状态，可以是用户身份，也可以是任务信息等。给每个方法增加一个上下文参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，上下文参数就传不进去了。<code>Java</code>标准库提供了一个特殊的<code>TheadLocal</code>，它可以在一个线程中传递同一个对象。</p>
<p>※ <code>ThreadLocal</code>实例通常以静态字段初始化，其典型使用方式如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：<code>ThreadLocal</code>一定要在<code>finally</code>中清除，因为当前线程执行完相关代码后，很可能会被重新放入线程池中，若<code>ThreadLocal</code>没有被清除，会把上一次的状态带进去。</p>
<p>※ 为了保证能释放<code>ThreadLocal</code>关联的实例，可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用的时候，借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) &#123;...&#125;</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>
</blockquote>
<h4 id="Day-002"><a href="#Day-002" class="headerlink" title="Day 002"></a>Day 002</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>Maven</code>是一个<code>Java</code>项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建。</p>
<p>※ 使用<code>Maven</code>管理的普通<code>Java</code>项目的目录结构默认如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，项目的根目录<code>a-maven-project</code>为项目名，它有一个<span style="color:blue">项目描述文件</span><code>pom.xml</code>，存放源码的目录为<code>src/main/java</code>，存放资源文件的目录为<code>src/main/resources</code>，存放测试源码的目录为<code>src/test/java</code>，存放测试资源文件的目录为<code>src/tset/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。</p>
<p>※ 通常情况下，项目描述文件<code>pom.xml</code>的内容如下所示：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，<code>groupId</code>类似于<code>Java</code>的包名，通常是公司或组织名称，<code>artifactId</code>类似于<code>Java</code>的类名，通常是项目名称，再加上<code>version</code>，即可作为唯一标识。在引用其它第三方库时，也是通过这三个变量确定的，如<code>commons-logging</code>：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，<code>Maven</code>就会自动下载这个依赖包并把它方法<code>classpath</code>中。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>Maven</code>定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：其中，默认的<code>compile</code>依赖最常用，<code>Maven</code>会把这种类型的依赖直接放入<code>classpath</code>中；<code>test</code>依赖表示仅在测试时使用，正常运行时不需要，如<code>JUnit</code>；<code>runtime</code>依赖表示编译时不需要，但运行时需要，如<code>MySQL</code>；<code>provided</code>依赖表示编译时需要，但运行时不需要，如<code>servle-api</code>。</p>
<p>※ <code>Maven</code>通过对<code>jar</code>包进行<code>PGP</code>签名确保任何一个<code>jar</code>包一经发布就无法修改，修改<code>jar</code>包的唯一方法为发布一个新版本。因此，某个<code>jar</code>包一旦被<code>Maven</code>下载过，即可永久地安全缓存在本地。<strong>注</strong>：只有以<code>-SNAPSHOT</code>结尾的版本号会被<code>Maven</code>视为开发版本，开发版本每次都会重复下载，这种<code>SNAPSHOT</code>版本只能用于内部私有的<code>Maven repo</code>，公开发布的版本不允许出现。</p>
<p>※ <code>Maven</code>并不会每次都从中央仓库下载<code>jar</code>包，一个<code>jar</code>包一旦被下载过，就会被<code>Maven</code>自动缓存在本地目录（用户主目录下的<code>.m2</code>目录）。因此，除第一次编译时因为下载需要时间会比较慢外，后续过程因为有本地缓存，并不会很慢。</p>
<p>※ 使用<code>Maven</code>镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>setting.xml</code>配置文件，内容如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置镜像仓库后，<code>Maven</code>的下载速度会很快。</p>
<p>※ 如果需要引用一个第三方组件，可以通过<a href="[Maven Central Repository Search](https://search.maven.org/)">search.maven.org</a>搜索关键字，找到对应的组件后直接复制即可。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>Maven</code>的<span style="color:blue">生命周期</span>由一系列阶段（<code>phase</code>）构成，以内置的生命周期<code>default</code>为例，它包含以下<a href="[构建流程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/1252599548343744/1309301196980257)">阶段</a>。如果我们运行<code>mvn package</code>，<code>Maven</code>就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个阶段为止；如果我们运行<code>mvn compile</code>，<code>Maven</code>也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>。此外，<code>Maven</code>另一个常用的生命周期为<code>clean</code>，它会执行三个阶段：<code>pre-clean</code>、<code>clean</code>、<code>post-clean</code>。</p>
<p>※ 在实际开发中，常用的命令有：<code>mvn clean</code>，清理所有生成的<code>class</code>和<code>jar</code>；<code>mvn clean compile</code>，先清理再执行到<code>compile</code>；<code>mvn clean test</code>，先清理再执行到<code>test</code>；<code>mvn clean package</code>：先清理再执行到<code>package</code>。<strong>注</strong>：大多数阶段在执行过程中，因为通常没有在<code>pom.xml</code>中配置相关设置，因此什么事情都不做，经常用到的阶段其实只有几个，如<code>clean</code>、<code>compile</code>、<code>test</code>、<code>package</code>。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ 实际上，执行每个阶段，都是通过某个插件来执行的，<code>Maven</code>本身并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个<code>goal</code>来完成编译。因此，使用<code>Maven</code>实际上就是配置好需要使用的插件，然后通过阶段调用它们。<strong>注</strong>：若标准插件无法满足需求，还可以使用自定义插件。使用自定义插件时，需要声明。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <code>Maven</code>可以有效管理多个模块，只需要把每个模块当作一个独立的<code>Maven</code>项目，每个项目有各自独立的<code>pom.xml</code>。</p>
<p>※ 不同模块的<code>pom.xml</code>高度相似，因此，可以提取出共同部分作为<code>parent</code>：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>parent</code>的<code>&lt;packing&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何<code>Java</code>代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ 安装完<code>Maven</code>之后，系统所有项目都会使用全局安装的这个<code>Maven</code>版本，但是对于某些项目来说，可能必须使用某个特定的<code>Maven</code>版本，这个时候就可以使用<code>Maven Wrapper</code>（<span style="color:blue"><code>mvnw</code></span>），它可以负责给这些项目安装指定版本的<code>Maven</code>，而其它项目不受影响。<code>mvnw</code>的另一个作用是把项目的<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>提交到版本库中，可以使所有开发人员使用统一的<code>Maven</code>版本。</p>
</blockquote>
<blockquote>
<!-- Part 007 -->

<p>※ 使用<code>Maven</code>发布一个<code>Artifact</code>时，可以发布到本地，然后由静态服务器提供<code>repo</code>服务，使用方必须声明<code>repo</code>地址；可以发布到<code>central.sonatype.org</code>，并自动同步到<code>Maven</code>中央仓库，需要前期申请账号以及本地配置；可以发布到<code>Github Packages</code>作为私有仓库使用，必须提供<code>Token</code>以及正确的权限才能使用和发布。</p>
</blockquote>
<h4 id="Day-003"><a href="#Day-003" class="headerlink" title="Day 003"></a>Day 003</h4><blockquote>
<!-- Part 001 -->

<p>※ 使用<code>Java</code>进行网络编程时，由虚拟机实现了底层复杂的网络协议，<code>Java</code>程序只需要调用<code>Java</code>标准库提供的接口，即可简单高效地编写网络程序。</p>
<p>※ <code>TCP/IP</code>协议泛指互联网协议，其中最重要的两个协议是<code>TCP</code>协议和<code>IP</code>协议。只有使用<code>TCP/IP</code>协议的计算机才能够联入互联网，使用其它网络协议是无法联入互联网的。</p>
<p>※ 在互联网中，一个<code>IP</code>地址用于唯一标识一个网络接口。一台连入互联网的计算机肯定有一个<code>IP</code>地址，但也可能有多个<code>IP</code>地址。<code>IP</code>地址既可以分为<code>IPv4</code>和<code>IPv6</code>，又可以分为公网<code>IP</code>地址和内网<code>IP</code>地址。公网<code>IP</code>地址可以直接被访问，内网<code>IP</code>地址只能在内网访问。内网<code>IP</code>地址类似于：<code>192.168.*.*</code>，<code>10.*.*.*</code>。</p>
<p>※ 如果一台计算机有两块网卡，那么除了本机地址<code>127.0.0.1</code>，它还可以有两个<code>IP</code>地址，这两个<code>IP</code>地址可以分别接入两个网络，使得它们连接起来。<strong>注</strong>：通常连接两个网络的设备是路由器或者交换机。</p>
<p> ※ 每台计算机都需要正确配置<code>IP</code>地址和子网掩码，根据它们可以计算网络号。若两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信；若两台计算机计算出的网络号不同，说明两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，这种设备通常被称为<span style="color:blue">网关</span>。网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫做<span style="color:blue">路由</span>。</p>
<p>※ 域名解析服务器<code>DNS</code>负责把域名翻译成对应的<code>IP</code>，客户端再根据<code>IP</code>地址访问服务器。<strong>注</strong>：用<code>nslookup</code>可以查看域名对应的<code>IP</code>地址。</p>
<p>※ <code>OSI</code>网络模型是<code>ISO</code>组织定义的一个计算机互联标准模型，目的是为了简化网络各层的操作，提供标准接口便于实现和维护，该模型从上到下依次是：应用层，提供应用程序之间的通信；表示层，处理数据的格式，加解密等；会话层，负责建立和维护对话；传输层，负责提供端到端的可靠传输；网络层，负责根据目标地址选择路由来传输数据；链路层和物理层负责把数据进行分片并且真正通过物理网络传输，如无线网和光纤等。互联网使用的<code>TCP/IP</code>模型并不是对应到<code>OSI</code>的<code>7</code>层模型，而是大致对应<code>OSI</code>的<code>5</code>层模型。</p>
<p>※ <code>IP</code>协议是一种分组交换传输协议；<code>TCP</code>协议是一种面向连接，可靠传输的协议；<code>UDP</code>协议是一种非面向连接，不可靠传输的协议。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>Socket</code>是一个抽象概念，应用程序通过一个<code>Socket</code>来建立一个远程连接，而<code>Socket</code>内部通过<code>TCP/IP</code>协议把数据传输到网络。</p>
<p>※ 一个<code>Socket</code>就是由<code>IP</code>地址和端口号组成，端口号总是由操作系统分配，它是<code>0 ~ 65535</code>之间的数字，其中，小于<code>1024</code>的端口属于特权端口，需要管理员权限，大于<code>1024</code>的端口可以由任意用户的应用程序打开。</p>
<p>※ 使用<code>Socket</code>进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器，它会主动监听某个指定的端口，另一个进行必须充当客户端，它必须主动连接服务器的<code>IP</code>地址和指定端口，如果连接成功，服务器和客户端就成功地建立了一个<code>TCP</code>连接，双方后继就可以随时发送和接收数据。因此，当<code>Socket</code>连接成功地再服务器和客户端之间建立后，对服务器来说，它的<code>Socket</code>是指定的<code>IP</code>地址和指定的端口号；对客户端来说，它的<code>Socket</code>是它所在计算机的<code>IP</code>地址和一个由操作系统分配的随机端口号。</p>
<p>※ 当<code>Socket</code>连接建立成功后，无论是服务器，还是客户端，都使用<code>Socket</code>实例进行网络通信。因为<code>TCP</code>是一种基于流的协议，因此，<code>Java</code>标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装<code>Socket</code>的数据流。</p>
<p>※ 使用<code>Java</code>进行<code>TCP</code>编程时，需要使用<code>Socket</code>模型：服务器用<code>ServerSocket</code>监听指定端口；客户端使用<code>Socket(InetAddress, port)</code>连接服务器；服务器用<code>accept()</code>接收连接并返回<code>Socket</code>；双方通过<code>Socket</code>打开<code>InputStream/OutputStream</code>读写数据。<strong>注</strong>：服务器通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率。</p>
<p>※ 在写入网络数据时，要调用<code>flush()</code>方法，若不调用，可能会发现客户端和服务器都收不到数据，这是因为我们以流的形式写入数据时，并不是一写入就立刻发送到网络，而是先写入到内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是提高传输效率。若缓冲区的数据很少，而我们又想把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ 与<code>TCP</code>相比，<code>UDP</code>没有创建连接，数据包也是一次收发一个，因此没有流的概念。</p>
<p>※ 在<code>Java</code>中使用<code>UDP</code>编程，仍然需要使用<code>Socket</code>，因为应用程序在使用<code>UDP</code>时必须指定<code>IP</code>地址和端口号。<strong>注</strong>：<code>UDP</code>端口和<code>TCP</code>端口虽然都使用<code>0 ~ 65535</code>，但他们属于两套独立的端口，即一个应用程序用<code>TCP</code>占用了端口<code>1234</code>，不影响另一个应用程序用<code>UDP</code>占用端口<code>1234</code>。</p>
<p>※ 服务器使用<code>DatagramSocket(port)</code>监听端口；客户端使用<code>DatagramSocket.connect</code>指定远程地址和端口；双方通过<code>receive()</code>和<code>send()</code>读写数据；<code>DatagramSocket</code>没有<code>IO</code>流接口，数据被直接写入<code>byte[]</code>缓冲区。</p>
</blockquote>
<blockquote>
<!-- Part 004 -->

<p>※ <code>SMTP</code>协议是一个建立在<code>TCP</code>协议之上的协议，任何程序发送邮件都必须遵守<code>SMTP</code>协议。</p>
</blockquote>
<blockquote>
<!-- Part 005 -->

<p>※ <code>HTTP</code>是目前<code>    Web</code>应用程序使用最广泛的基础协议，翻译为超文本传输协议。</p>
<p>※ 当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立<code>TCP</code>连接，并且服务器总是使用<code>80</code>端口和加密端口<code>443</code>；然后，浏览器向服务器发送一个<code>HTTP</code>请求，服务器收到后返回一个<code>HTTP</code>响应，并且在响应中包含了<code>HTML</code>网页内容，这样，浏览器解析<code>HTML</code>后就可以给用户显示网页了。</p>
<p>※ <code>HTTP</code>请求的格式是固定的，由<code>Header</code>和<code>Body</code>两部分构成。第一行总是“请求方法 路径 <code>HTTP</code>版本”，后继的每一行都是固定的<code>Header: Value</code>格式，称之为<code>HTTP Header</code>，服务器依靠某些特定的<code>Header</code>来识别客户端请求，其中，<code>Host</code>表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠<code>Host</code>来识别请求；<code>User-Agent</code>表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠其判断客户端类型；<code>Accept</code>表示客户端能处理的<code>HTTP</code>响应格式，<code>*/*</code>表示惹你格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示<code>PNG</code>格式的图片；<code>Accept-Language</code>表示客户端接收的语言，多种语言按照优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。<strong>注</strong>：如果是<code>GET</code>请求，那么该<code>HTTP</code>请求只有<code>Header</code>，没有<code>Body</code>；如果是<code>POST</code>请求，那么该<code>HTTP</code>请求带有<code>Body</code>，以一个空行分隔。一个典型的带有<code>Body</code>的<code>HTTP</code>请求如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 30</span><br><span class="line"></span><br><span class="line">username=hello&amp;password=123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示<code>Body</code>类型，<code>Content-Length</code>表示<code>Body</code>长度，这样服务器就可以根据请求的<code>Header</code>和<code>Body</code>做出正确的响应。此外，<code>GET</code>请求的参数必须附加在<code>URL</code>上，并以<code>URLEncode</code>方式编码。</p>
<p>※ <code>HTTP</code>响应同样是由<code>Header</code>和<code>Body</code>两部分构成。第一行总是“<code>HTTP</code>版本 响应代码 响应说明”。客户端只依赖响应代码判断<code>HTTP</code>响应是否成功，其中，<code>1**</code>表示一个提示性响应，如<code>101</code>表示将切换协议，常见于<code>WebSocket</code>连接；<code>2**</code>表示一个成功响应，如<code>200</code>表示成功，<code>206</code>表示只发送了部分内容；<code>3**</code>表示一个重定向响应，如<code>301</code>表示永久重定向，<code>303</code>表示客户端应该按照指定路径重新发送请求；<code>4**</code>表示一个因为客户端问题导致的错误响应，如<code>400</code>表示因为<code>Content-Type</code>等各种原因导致的无效请求，<code>404</code>表示指定的路径不存在；<code>5**</code>表示一个因为服务器问题导致的错误响应，如<code>500</code>表示服务器内部故障，<code>503</code>表示服务器暂时无法响应。</p>
<p>※ 当浏览器收到第一个<code>HTTP</code>响应并解析<code>HTML</code>后，又会发送一系列<code>HTTP</code>请求，如<code>GET /log.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器。因此，服务器总是被动地接收客户端的一个<code>HTTP</code>请求，然后响应它；客户端则根据需要发送若干个<code>HTTP</code>请求。</p>
<p>※ 对于最早期的<code>HTTP/1.0</code>协议，每次发送一个<code>HTTP</code>请求后，客户端都需要先创建一个新的<code>TCP</code>连接，待收到服务器响应后，关闭这个<code>TCP</code>连接。由于建立<code>TCP</code>连接比较耗时，为了提高效率，<code>HTTP/1.1</code>协议允许在一个<code>TCP</code>连接中反复请求-响应，这样就能大大提高效率。然而，<code>HTTP</code>协议是一个请求-响应协议，客户端在发送了一个<code>HTTP</code>请求后，必须等待服务器响应后才能发送下一个请求，这样以来，若某个响应太慢，将会堵住后面的请求。因此，为了进一步提速，<code>HTTP/2.0</code>允许客户在没有收到响应的时候，发送多个<code>HTTP</code>请求，服务器返回响应时，不一定按照顺序返回，只要双方能识别出哪个响应对应哪个请求，即可做到并行发送和接收。</p>
</blockquote>
<blockquote>
<!-- Part 006 -->

<p>※ <code>Java</code>的<code>RMI</code>远程调用是指：一个<code>JVM</code>中的代码可以通过网络远程调用另一个<code>JVM</code>的某个方法，提供服务的一方称为服务器，实现远程调用的一方称之为客户端。</p>
<p>※ <code>RMI</code>通过自动生成<code>stub</code>和<code>skeleton</code>实现网络调用，客户端只需要查找服务并获得接口实例，服务端只需要编写实现类并注册为服务。此外，<code>RMI</code>的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把<code>1099</code>端口暴露再公网上作为对外服务。</p>
</blockquote>
<h4 id="Day-004"><a href="#Day-004" class="headerlink" title="Day 004"></a>Day 004</h4><blockquote>
<!-- Part 001 -->

<p>※ <code>XML</code>是可扩展标记语言的缩写，属于一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。<code>XML</code>有几个特点：一是纯文本，默认使用<code>UTF-8</code>编码；二是可嵌套，适合表示结构化数据。</p>
<p>※ <code>XML</code>有固定的结构，首行必定是<code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>，有时还可以加上可选的编码。紧接着，如果以类似<code>&lt;!DOCTYPE note SYSTEM &quot;book.dtd&quot;&gt;</code>声明的是<span style="color:blue">文档定义类型</span><code>DTD</code>，<code>DTD</code>是可选的。接下来是<code>XML</code>的文档内容，一个<code>XML</code>文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性。</p>
<p>※ 验证<code>XML</code>正确性最简单的方式是通过浏览器验证，即直接把<code>XML</code>文件拖拽到浏览器窗口，若格式错误，浏览器将会报错。</p>
</blockquote>
<blockquote>
<!-- Part 002 -->

<p>※ <code>XML</code>为树形结构的文档，它有两种标准的解析<code>API</code>：<code>DOM</code>，一次性读取<code>XML</code>，并在内存中表示为树形结构；<code>SAX</code>，以流的形式读取<code>XML</code>，使用事件回调。<strong>注</strong>：<code>DOM</code>解析速度慢，内存占用大；<code>SAX</code>读取速度快，内存站占用小。</p>
</blockquote>
<blockquote>
<!-- Part 003 -->

<p>※ <code>JSON</code>是轻量级的数据表示方式，常用于<code>Web</code>应用；<code>Jackson</code>可以实现<code>JavaBean</code>和<code>JSON</code>之间的转换；可以通过<code>Module</code>扩展<code>Jackson</code>能处理的数据类型；可以自定义<code>JsonSerializer</code>和<code>JsonDeserializer</code>来定制序列化和反序列化。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%AB%98%E7%BA%A7/" rel="tag"># 高级</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/09/Java-02-%E4%B8%AD%E7%BA%A7/" rel="prev" title="Java中级">
                  <i class="fa fa-chevron-left"></i> Java中级
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/07/Java-04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/" rel="next" title="Java多线程与并发">
                  Java多线程与并发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘晨</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
