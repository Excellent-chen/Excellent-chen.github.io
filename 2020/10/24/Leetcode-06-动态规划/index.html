<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="中等 300. 最长上升子序列 ※ $O(N^2)$的动态规划就好，$O(NlogN)$的贪心+二分法不适合我。。。  1234567891011121314151617class Solution &amp;#123;    public int lengthOfLIS(int[] nums) &amp;#123;        int res &#x3D; 1;        int n &#x3D; nums.length;">
<meta property="og:type" content="article">
<meta property="og:title" content="06 动态规划">
<meta property="og:url" content="http://example.com/2020/10/24/Leetcode-06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="阿晨的博客">
<meta property="og:description" content="中等 300. 最长上升子序列 ※ $O(N^2)$的动态规划就好，$O(NlogN)$的贪心+二分法不适合我。。。  1234567891011121314151617class Solution &amp;#123;    public int lengthOfLIS(int[] nums) &amp;#123;        int res &#x3D; 1;        int n &#x3D; nums.length;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-24T08:26:43.000Z">
<meta property="article:modified_time" content="2020-12-26T08:01:26.623Z">
<meta property="article:author" content="刘晨">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/10/24/Leetcode-06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>06 动态规划 | 阿晨的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">阿晨的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">年度最佳摸鱼选手</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E7%AD%89"><span class="nav-number">1.</span> <span class="nav-text">中等</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.</span> <span class="nav-text">300. 最长上升子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">1.2.</span> <span class="nav-text">309. 最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">1.3.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6"><span class="nav-number">1.4.</span> <span class="nav-text">486. 预测赢家</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.5.</span> <span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="nav-number">1.6.</span> <span class="nav-text">714. 买卖股票的最佳时机含手续费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#764-%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97"><span class="nav-number">1.7.</span> <span class="nav-text">764. 最大加号标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#799-%E9%A6%99%E6%A7%9F%E5%A1%94"><span class="nav-number">1.8.</span> <span class="nav-text">799. 香槟塔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7"><span class="nav-number">1.9.</span> <span class="nav-text">983. 最低票价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1024-%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.10.</span> <span class="nav-text">1024. 视频拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1043-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">1.11.</span> <span class="nav-text">1043. 分隔数组以得到最大和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II"><span class="nav-number">1.12.</span> <span class="nav-text">1049. 最后一块石头的重量 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1105-%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6"><span class="nav-number">1.13.</span> <span class="nav-text">1105. 填充书架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.14.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1314-%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C"><span class="nav-number">1.15.</span> <span class="nav-text">1314. 矩阵区域和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%B0%E9%9A%BE"><span class="nav-number">2.</span> <span class="nav-text">困难</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="nav-number">2.1.</span> <span class="nav-text">174. 地下城游戏</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘晨"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">刘晨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/24/Leetcode-06-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="刘晨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿晨的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          06 动态规划
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-24 16:26:43" itemprop="dateCreated datePublished" datetime="2020-10-24T16:26:43+08:00">2020-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-26 16:01:26" itemprop="dateModified" datetime="2020-12-26T16:01:26+08:00">2020-12-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><hr>
<h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h4><blockquote>
<p>※ $O(N^2)$的动态规划就好，$O(NlogN)$的贪心+二分法不适合我。。。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>], dp[j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N)$。</p>
</blockquote>
<a id="more"></a>

<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h4><blockquote>
<p>※ 令<code>f[i]</code>表示第<code>i</code>天结束后的累计最大收益，则<code>f[i]</code>对应了三种状态：目前持有一只股票，对应的累计最大收益为<code>f[i][0]</code>；目前不持有股票，并且处于冷冻期中，对应的累计最大收益为<code>f[i][1]</code>；目前不持有股票，并且未处于冷冻期中，对应的累计最大收益为<code>f[i][2]</code>。它们的状态转移方程分别如下：</p>
<p><code>f[i][0] = Math.max(f[i - 1][0], f[i - 1][2] - price[i])</code>；<code>f[i][1] = f[i - 1][0] + price[i]</code>；<code>f[i][2] = Math.max(f[i - 1][1], f[i - 1][2])</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f_0 = - prices[<span class="number">0</span>], f_1 = <span class="number">0</span>, f_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_f_0 = Math.max(f_0, f_2 - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> new_f_1 = f_0 + prices[i];</span><br><span class="line">            <span class="keyword">int</span> new_f_2 = Math.max(f_1, f_2);</span><br><span class="line">            f_0 = new_f_0;</span><br><span class="line">            f_1 = new_f_1;</span><br><span class="line">            f_2 = new_f_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f_1, f_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h4><blockquote>
<p>※ 该题目与常规<code>0-1</code>背包问题的区别在于：要求精确等于整个数组元素的和的一半，这使得对状态矩阵进行初始化时，所有的值都应该初始化为<code>false</code>。此外，对于一些特殊情况，可以直接判断出最终的结果，这一点需要注意。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 1. 若 n &lt; 2 则不能将数组分割成元素和相等的两个子集，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 若 sum 为奇数或者 max &gt; sum / 2，直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span> || max &gt; sum / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 若不选取任何正整数，则被选取的正整数等于零，这一步貌似挺重要的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] |= dp[j - nums[i]]; <span class="comment">// 注：每个数字只能使用一次，因此从后往前遍历是可以的！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N * target)$；空间复杂度：$O(target)$。</p>
</blockquote>
<h4 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h4><blockquote>
<p>※ 定义行数与列数均等于数组长度的二维数组<code>dp</code>，其中，<code>dp[i][j]</code>表示当数组剩下的部分为下标<code>i</code>到下标<code>j</code>时，当前玩家与另一个玩家的分数之差的最大值。只有当<code>i &lt;= j</code>时，数组剩下的部分才有意义，因此当<code>i &gt; j</code>时，均有<code>dp[i][j] = 0</code>；当<code>i = j</code>时，只剩一个数字，当前玩家只能拿取该数字，因此对于所有<code>0 &lt;= i &lt; nums.length</code>，均有<code>dp[i][j] = nums[i]</code>；当<code>i &lt; j</code>时，当前玩家可以选择<code>nums[i]</code>或<code>nums[j]</code>，然后轮到另一个玩家在数组剩下的部分选取数字。在上述两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化。因此可以得到如下状态转移方程：<code>dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])</code>，最后判断<code>dp[0][nums.length - 1]</code>的值，如果其大于或等于<code>0</code>，说明先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N^2)$。</p>
</blockquote>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h4><blockquote>
<p>※ 建立二维数组<code>dp[s.length()][dp.length()]</code>，其中，<code>dp[i][j]</code>表示字符串第<code>i</code>个字符与第<code>j</code>个字符之间的所有字符构成的子字符串中最长回文子序列的长度（包括第<code>i</code>个字符和第<code>j</code>个字符）。易知，若<code>s.charAt(i) == s.charAt(j)</code>，则有<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>；若<code>s.charAt(i) != s.charAt(j)</code>，则有<code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</code>。基于上述递推公式，可以得知，从后往前更新<code>dp</code>更为合适。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N^2)$。</p>
</blockquote>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h4><blockquote>
<p>※ 用变量<code>not_hold[i]</code>表示第<code>i</code>天不持有股票时的利润，<code>hold[i]</code>表示第<code>i</code>天持有股票时的理论，可得如下状态转移方程：</p>
<p><code>not_hold[i] = Math.max(not_hold[i - 1], hold[i - 1] + prices[i] - fee)</code>，</p>
<p><code>hold[i] = Math.max(hold[i], not_hold[i - 1] + prices[i])</code>，</p>
<p>在初始时，有<code>not_hold[0] = 0</code>，<code>hold[0] = - prices[0]</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> not_hold = <span class="number">0</span>, hold = - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> old_hold = not_hold;</span><br><span class="line">            not_hold = Math.max(not_hold, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, old_hold - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> not_hold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N)$；空间复杂度：$O(1)$。</p>
</blockquote>
<h4 id="764-最大加号标志"><a href="#764-最大加号标志" class="headerlink" title="764. 最大加号标志"></a>764. 最大加号标志</h4><blockquote>
<p>※ 预先计算每个中心点坐标在四个方向上对应的最长臂长$L_u$、$L_l$、$L_d$和$L_r$，则以该中心点坐标为中心可以构成的加号的阶为$min(L_u,L_l,L_d,L_r)$。特别的，对于每个中心点坐标<code>grid[i][j]</code>，若<code>grid[i][j] = 0</code>，则臂长为<code>0</code>；若<code>grid[i][j] = 1</code>，则臂长为当前方向上连续<code>1</code>的个数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] mines)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; banned = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] mine : mines) &#123;</span><br><span class="line">            banned.add(mine[<span class="number">0</span>] * N + mine[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算每个位置左边有几个连续的一（包括自己）</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                count = banned.contains(i * N + j) ? <span class="number">0</span> : count + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算每个位置右边有几个连续的一（包括自己）</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                count = banned.contains(i * N + j) ? <span class="number">0</span> : count + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                count = banned.contains(i + j * N) ? <span class="number">0</span> : count + <span class="number">1</span>;</span><br><span class="line">                dp[j][i] = Math.min(dp[j][i], count);</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                count = banned.contains(i + j * N) ? <span class="number">0</span> : count + <span class="number">1</span>;</span><br><span class="line">                dp[j][i] = Math.min(dp[j][i], count);</span><br><span class="line">                res = Math.max(res, dp[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N^2)$。</p>
</blockquote>
<h4 id="799-香槟塔"><a href="#799-香槟塔" class="headerlink" title="799. 香槟塔"></a>799. 香槟塔</h4><blockquote>
<p>※ 记录流入每个杯子的香槟的杯数之和<code>X</code>，若<code>X</code>大于<code>1</code>，那么将会有<code>(X - 1.0) / 2</code>的香槟流入下一层相邻的两个杯子中，依次类推，利用动态规划进行求解即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">champagneTower</span><span class="params">(<span class="keyword">int</span> poured, <span class="keyword">int</span> query_row, <span class="keyword">int</span> query_glass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][] dp = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = poured;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= query_row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] += (dp[i][j] - <span class="number">1.0</span>) / <span class="number">2</span>;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] += (dp[i][j] - <span class="number">1.0</span>) / <span class="number">2</span>;</span><br><span class="line">                    dp[i][j] = <span class="number">1.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[query_row][query_glass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N^2)$。</p>
</blockquote>
<h4 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a>983. 最低票价</h4><blockquote>
<p>※ 记第<code>N</code>天的最低票价为<code>F(N)</code>，假设已经求出了前<code>N - 1</code>天的最低票价，现在来求<code>F(N)</code>。如果第<code>N</code>天要选择有效期长度为<code>dayOfPass</code>的通行证，其价格为<code>cost</code>，那么在第<code>N - dayOfPass</code>天时就应该买入该通行证，才能使利益最大化；而我们已经求出了前<code>N - 1</code>天的最低票价，即<code>F(N - dayOfPass)</code>是已知的。因此，对于该选择，其花费为<code>F(N - dayOfPass) + cost</code>，取所有选择的最小值更新<code>F(N)</code>即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, n = days.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days[n - <span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[pos] == i) &#123;</span><br><span class="line">                <span class="keyword">int</span> d1 = i - <span class="number">1</span> &gt; <span class="number">0</span> ? i - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> d2 = i - <span class="number">7</span> &gt; <span class="number">0</span> ? i - <span class="number">7</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> d3 = i - <span class="number">30</span> &gt; <span class="number">0</span> ? i - <span class="number">30</span> : <span class="number">0</span>;</span><br><span class="line">                dp[i] = Math.min(dp[d1] + costs[<span class="number">0</span>], Math.min(dp[d2] + costs[<span class="number">1</span>], dp[d3] + costs[<span class="number">2</span>]));</span><br><span class="line">                pos++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(W)$，其中，<code>W</code>表示旅行计划中日期的最大值；空间复杂度：$O(W)$。</p>
</blockquote>
<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h4><blockquote>
<p>※ 该题目与<code>55. 跳跃游戏</code>类似，只是多了一个转换的过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[T + <span class="number">1</span>]; <span class="comment">// 保存以 i 为起点所能到达的最远距离。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] clip : clips) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clip[<span class="number">0</span>] &lt; T) &#123; <span class="comment">// ???</span></span><br><span class="line">                max[clip[<span class="number">0</span>]] = Math.max(max[clip[<span class="number">0</span>]], clip[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, max_n = <span class="number">0</span>, next_max_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T &amp;&amp; i&lt;= next_max_n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; max_n) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                max_n = next_max_n;</span><br><span class="line">            &#125;</span><br><span class="line">            next_max_n = Math.max(next_max_n, max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next_max_n &lt; T) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(T)$；空间复杂度：$O(T + N)$，其中，<code>T</code>表示区间的长度，<code>N</code>表示子区间的数量。</p>
</blockquote>
<h4 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043. 分隔数组以得到最大和"></a>1043. 分隔数组以得到最大和</h4><blockquote>
<p>※ 令<code>dp[i]</code>表示数组前<code>i</code>个元素（包含第<code>i</code>个元素）对应的结果，则<code>dp[i + 1] = max(dp[i - j] + max(arr[i + 1], ..., arr[i + 1 - j]) * (j + 1))</code>，其中<code>j = 1, ..., k</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, arr[i - j]);</span><br><span class="line">                dp[i + <span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>], dp[i - j] + max * (j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(NK)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a>1049. 最后一块石头的重量 II</h4><blockquote>
<p>※ 该题目可以近似视为<code>0-1</code>背包问题，即将所有的石头分为两堆，并使得它们的总重相差最少（详情请见<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/you-qian-ru-shen-si-lu-ji-0-1-bei-bao-xiang-jie-mo/">解析</a>）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = dp.length - <span class="number">1</span>; i &gt;= stone; i--) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - stone] + stone); <span class="comment">// 对空间进行压缩时需要倒序遍历！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[sum / <span class="number">2</span>]; <span class="comment">// 这里是 sum - 2 * dp[sum / 2] 而不是 sum - dp[sum / 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(M * N)$，其中，<code>M</code>表示石块总重，<code>N</code>表示石块的个数；空间复杂度：$O(M)$。</p>
</blockquote>
<h4 id="1105-填充书架"><a href="#1105-填充书架" class="headerlink" title="1105. 填充书架"></a>1105. 填充书架</h4><blockquote>
<p>※ 用<code>dp[i + 1]</code>表示放置前<code>i</code>本书所需要的书架的最小高度，遍历每一本书，并将该书作为书架最后一层的最后一本书，将该书之前的书向后调整，看是否可以减少之前的书架高度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(<span class="keyword">int</span>[][] books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = books.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_hight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> total_width = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                total_width += books[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (total_width &lt;= shelf_width) &#123;</span><br><span class="line">                    max_hight = Math.max(max_hight, books[j][<span class="number">1</span>]);</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>], dp[j] + max_hight);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(N^2)$；空间复杂度：$O(N)$。</p>
</blockquote>
<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h4><blockquote>
<p>※ 令<code>dp[i][j]</code>表示字符串<code>S1[0:i]</code>与字符串<code>S2[0:j]</code>的最长公共子序列，则有<code>S1[i] = S2[j]</code>时，<code>dp[i][j] = dp[i - 1][j - 1]</code>；<code>S1[i] != S2[j]</code>时，<code>dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = text1.length(), cols = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = text1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars2 = text2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chars1[i] == chars2[j]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows][cols];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<h4 id="1314-矩阵区域和"><a href="#1314-矩阵区域和" class="headerlink" title="1314. 矩阵区域和"></a>1314. 矩阵区域和</h4><blockquote>
<p>※ 用二维数组<code>dp</code>表示<code>mat</code>的前缀和，其中，<code>dp[i][j]</code>表示<code>mat</code>中以<code>(0, 0)</code>为左上角，<code>(i - 1, j - 1)</code>为右下角的子矩形的元素之和。题目需要对<code>mat</code>中的每个位置，计算以<code>(i - K, j - K)</code>为左上角，<code>(i + K, j + K)</code>为右下角的子矩形的元素之和，我们可以在前缀和的帮助下，通过：</p>
<p>$sum = dp[i + K + 1][j + K + 1] - dp[i - K][j + K + 1] - dp[i + K + 1][j - K] + dp[i - K][j - K]$</p>
<p>得到元素之和。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixBlockSum(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> rows = mat.length, cols = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                dp[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Math.max(<span class="number">0</span>, i - K);</span><br><span class="line">                <span class="keyword">int</span> b = Math.min(rows - <span class="number">1</span>, i + K);</span><br><span class="line">                <span class="keyword">int</span> l = Math.max(<span class="number">0</span>, j - K);</span><br><span class="line">                <span class="keyword">int</span> r = Math.min(cols - <span class="number">1</span>, j + K);</span><br><span class="line">                res[i][j] = dp[b + <span class="number">1</span>][r + <span class="number">1</span>] + dp[t][l] - dp[b + <span class="number">1</span>][l] - dp[t][r + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<hr>
<h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><hr>
<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a>174. 地下城游戏</h4><blockquote>
<p>※ 令<code>dp[i][j]</code>表示从坐标<code>(i, j)</code>到终点所需的最小初始值，即当我们到达坐标<code>(i, j)</code>时，若此时的路径和不小于<code>dp[i][j]</code>，便可到达终点。对于<code>dp[i][j]</code>，我们只需关心<code>dp[i][j + 1]</code>和<code>dp[i + 1][j]</code>的最小值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length, n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; -<span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = Math.min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>, min - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>※ 时间复杂度：$O(MN)$；空间复杂度：$O(MN)$。</p>
</blockquote>
<hr>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/20/Java-01-%E5%9F%BA%E7%A1%80/" rel="prev" title="Java基础">
                  <i class="fa fa-chevron-left"></i> Java基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/09/Java-02-%E4%B8%AD%E7%BA%A7/" rel="next" title="Java中级">
                  Java中级 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘晨</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
